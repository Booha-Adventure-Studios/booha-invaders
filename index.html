<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Booha Invaders — Stage 1 (Art Build)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  // -----------------------
  // Assets (FOLDERS)
  // -----------------------
  // Images in: assets/
  // Audio later in: audio/  (no audio code yet)
  const ASSETS = {
    bg: "assets/background.png",
    booIdle: "assets/booha-invad-1.png",
    booShoot: "assets/booha-invad-2.png",
    bug1: "assets/bug-1.png",
    rocks: [
      "assets/rock1.png",
      "assets/rock2.png",
      "assets/rock3.png",
      "assets/rock4.png"
    ]
  };

  function loadImg(src){
    return new Promise((res, rej)=>{
      const img = new Image();
      img.onload = ()=>res(img);
      img.onerror = ()=>rej(new Error("Failed to load: " + src));
      img.src = src;
    });
  }

  let IMG = null;

  // -----------------------
  // Resize / DPR
  // -----------------------
  const DPR_CAP = 2;
  let DPR = 1;
  function resize(){
    DPR = Math.min(window.devicePixelRatio || 1, DPR_CAP);
    canvas.width = Math.floor(innerWidth * DPR);
    canvas.height = Math.floor(innerHeight * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0); // draw in CSS pixels
  }
  addEventListener("resize", resize);

  // -----------------------
  // Helpers
  // -----------------------
  const rand = (a,b)=>a + Math.random()*(b-a);
  const clamp = (v,a,b)=>Math.max(a, Math.min(b, v));
  const lerp = (a,b,t)=>a+(b-a)*t;

  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
  function easeInOutSine(t){ return -(Math.cos(Math.PI * t) - 1) / 2; }

  function aabb(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  // -----------------------
  // World / Entities
  // -----------------------
  const W = ()=>innerWidth;
  const H = ()=>innerHeight;

  const keys = new Set();
  addEventListener("keydown", (e)=>{
    if(["ArrowLeft","ArrowRight"," ","Space","Spacebar"].includes(e.key)) e.preventDefault();
    keys.add(e.key);
  }, {passive:false});
  addEventListener("keyup", (e)=>keys.delete(e.key));

  const player = {
    x: 0, y: 0,
    w: 76, h: 76,
    speed: 460,
    canShootIn: 0,
    shootFlash: 0,
    glow: 0
  };

  const rocks = [];      // {x,y,w,h,hp:4..0}
  const booShots = [];   // golden sparkly shots
  const bugShots = [];   // slime green blobs

  const sparkles = [];   // gold particles
  const slimePuffs = []; // slime particles

  const bugs = [];       // bug entities

  const stage = {
    t: 0,
    spawnTimer: 0,
    spawnInterval: 2.4,
    maxBugsOnScreen: 1,
    bugFireBase: 2.2,
    bugFireJitter: 1.0,
    bugDrift: 12,
  };

  function resetStage1(){
    stage.t = 0;
    stage.spawnTimer = 0;
    stage.spawnInterval = 2.4;
    stage.maxBugsOnScreen = 1;
    stage.bugFireBase = 2.2;
    stage.bugFireJitter = 1.0;

    bugs.length = 0;
    booShots.length = 0;
    bugShots.length = 0;
    sparkles.length = 0;
    slimePuffs.length = 0;

    const size = clamp(W()*0.10, 64, 92);
    player.w = size;
    player.h = size;
    player.x = W()/2 - player.w/2;
    player.y = H() - player.h - 18;
    player.canShootIn = 0;
    player.shootFlash = 0;
    player.glow = 0;

    // Rocks: BUG shots can damage rocks; Booha shots cannot.
    rocks.length = 0;
    const count = 4;
    const rockW = clamp(W()*0.18, 110, 160);
    const rockH = rockW * 0.72;
    const gap = (W() - count*rockW) / (count + 1);
    const y = player.y - rockH - 55;

    for(let i=0;i<count;i++){
      rocks.push({
        x: gap + i*(rockW + gap),
        y,
        w: rockW,
        h: rockH,
        hp: 4
      });
    }
  }

  function spawnBug(){
    const lanes = 6;
    const laneW = W() / lanes;
    const lane = (Math.random()*lanes)|0;
    const targetX = lane*laneW + laneW/2;

    const bw = clamp(W()*0.065, 44, 62);
    const bh = bw;

    const targetY = clamp(H()*0.18, 90, 150) + rand(0, 40);

    const startX = targetX + rand(-laneW*0.35, laneW*0.35);
    const startY = -bh - rand(30, 120);

    const enterDur = rand(0.9, 1.3);

    bugs.push({
      x: startX, y: startY,
      w: bw, h: bh,
      alive: true,
      state: "enter",
      tEnter: 0,
      enterDur,
      startX, startY,
      targetX: targetX - bw/2,
      targetY,
      shootCD: rand(stage.bugFireBase - stage.bugFireJitter, stage.bugFireBase + stage.bugFireJitter),
      glow: 0,
      bobT: rand(0, 10)
    });
  }

  function addSpark(x,y, n=6){
    for(let i=0;i<n;i++){
      sparkles.push({
        x, y,
        vx: rand(-120, 120),
        vy: rand(-180, 80),
        life: 0,
        ttl: rand(0.25, 0.45),
        size: rand(1.5, 3.4)
      });
    }
  }

  function addSlimePuff(x,y, n=5){
    for(let i=0;i<n;i++){
      slimePuffs.push({
        x, y,
        vx: rand(-90, 90),
        vy: rand(-60, 60),
        life: 0,
        ttl: rand(0.25, 0.5),
        size: rand(3, 7)
      });
    }
  }

  function fireBooShot(){
    const sx = player.x + player.w/2;
    const sy = player.y + 8;

    booShots.push({
      x: sx, y: sy,
      vx: 0, vy: -980,
      r: 6,
      alive: true
    });

    player.shootFlash = 0.10;
    player.glow = 0.18;
  }

  function fireBugShot(bug){
    const sx = bug.x + bug.w/2;
    const sy = bug.y + bug.h + 6;

    bugShots.push({
      x: sx, y: sy,
      vx: rand(-60, 60),
      vy: rand(290, 410),
      r: rand(7, 10),
      alive: true,
      t: 0
    });

    bug.glow = 0.22;
  }

  // -----------------------
  // Update / Draw
  // -----------------------
  let last = 0;

  function update(dt){
    stage.t += dt;

    // Difficulty ramp (gentle)
    if(stage.t > 10){
      stage.maxBugsOnScreen = 2;
      stage.spawnInterval = lerp(2.4, 1.8, clamp((stage.t-10)/15, 0, 1));
    }
    if(stage.t > 28){
      stage.maxBugsOnScreen = 3;
      stage.spawnInterval = lerp(1.8, 1.25, clamp((stage.t-28)/20, 0, 1));
      stage.bugFireBase = lerp(2.2, 1.4, clamp((stage.t-28)/22, 0, 1));
      stage.bugFireJitter = lerp(1.0, 0.6, clamp((stage.t-28)/22, 0, 1));
    }

    // Spawn bugs at intervals
    stage.spawnTimer -= dt;
    const aliveCount = bugs.reduce((n,b)=>n+(b.alive?1:0),0);
    if(stage.spawnTimer <= 0 && aliveCount < stage.maxBugsOnScreen){
      spawnBug();
      stage.spawnTimer = stage.spawnInterval + rand(-0.15, 0.25);
    }

    // Player
    const left = keys.has("ArrowLeft");
    const right = keys.has("ArrowRight");
    if(left) player.x -= player.speed * dt;
    if(right) player.x += player.speed * dt;
    player.x = clamp(player.x, 10, W()-player.w-10);

    player.canShootIn = Math.max(0, player.canShootIn - dt);
    player.shootFlash = Math.max(0, player.shootFlash - dt);
    player.glow = Math.max(0, player.glow - dt);

    const shoot = keys.has(" ") || keys.has("Space") || keys.has("Spacebar");
    if(shoot && player.canShootIn <= 0){
      const active = booShots.some(s=>s.alive);
      if(!active){
        fireBooShot();
        player.canShootIn = 0.24;
      }
    }

    // Bugs
    for(const b of bugs){
      if(!b.alive) continue;

      b.glow = Math.max(0, b.glow - dt);
      b.bobT += dt;

      if(b.state === "enter"){
        b.tEnter += dt;
        const t = clamp(b.tEnter / b.enterDur, 0, 1);
        const e = easeOutCubic(t);

        const curve = Math.sin(t*Math.PI) * (W()*0.02) * (Math.random() < 0.5 ? -1 : 1);
        b.x = lerp(b.startX, b.targetX, e) + curve * (1 - t);
        b.y = lerp(b.startY, b.targetY, easeInOutSine(t));

        if(t >= 1){
          b.state = "active";
          b.x = b.targetX;
          b.y = b.targetY;
        }
      } else {
        const driftX = Math.sin(b.bobT*0.9) * stage.bugDrift;
        const driftY = Math.cos(b.bobT*1.1) * (stage.bugDrift*0.35);
        b.x = b.targetX + driftX;
        b.y = b.targetY + driftY;

        b.shootCD -= dt;
        if(b.shootCD <= 0){
          fireBugShot(b);
          b.shootCD = rand(stage.bugFireBase - stage.bugFireJitter, stage.bugFireBase + stage.bugFireJitter);
          b.shootCD = Math.max(0.55, b.shootCD);
        }
      }
    }

    // Boo shots (gold) — hit bugs ONLY (never rocks)
    for(const s of booShots){
      if(!s.alive) continue;
      s.y += s.vy * dt;
      addSpark(s.x + rand(-2,2), s.y + 14 + rand(-2,2), 2);

      for(const b of bugs){
        if(!b.alive) continue;
        if(aabb(s.x - s.r, s.y - s.r, s.r*2, s.r*2, b.x, b.y, b.w, b.h)){
          b.alive = false;
          s.alive = false;
          addSpark(b.x + b.w/2, b.y + b.h/2, 18);
          break;
        }
      }
      if(s.y < -40) s.alive = false;
    }

    // Bug shots (slime) — can damage rocks
    for(const bl of bugShots){
      if(!bl.alive) continue;
      bl.t += dt;

      const wob = Math.sin(bl.t*6) * 0.9;
      bl.x += (bl.vx * (1 + wob)) * dt;
      bl.y += bl.vy * dt;

      if(Math.random() < 0.55) addSlimePuff(bl.x, bl.y, 1);

      for(const r of rocks){
        if(r.hp <= 0) continue;
        if(aabb(bl.x - bl.r, bl.y - bl.r, bl.r*2, bl.r*2, r.x, r.y, r.w, r.h)){
          r.hp = Math.max(0, r.hp - 1);
          bl.alive = false;
          addSlimePuff(bl.x, bl.y, 10);
          break;
        }
      }

      if(bl.y > H() + 60) bl.alive = false;
    }

    // Particles
    for(const p of sparkles){
      p.life += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 420 * dt;
    }
    for(let i=sparkles.length-1;i>=0;i--){
      if(sparkles[i].life >= sparkles[i].ttl) sparkles.splice(i,1);
    }

    for(const p of slimePuffs){
      p.life += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= 0.98;
      p.vy *= 0.98;
    }
    for(let i=slimePuffs.length-1;i>=0;i--){
      if(slimePuffs[i].life >= slimePuffs[i].ttl) slimePuffs.splice(i,1);
    }
  }

  function drawGlowRing(x,y, r, alpha, color){
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawBackground(){
    if(IMG?.bg){
      const iw = IMG.bg.width, ih = IMG.bg.height;
      const scale = Math.max(W()/iw, H()/ih);
      const dw = iw*scale, dh = ih*scale;
      const dx = (W()-dw)/2, dy = (H()-dh)/2;
      ctx.drawImage(IMG.bg, dx, dy, dw, dh);
    } else {
      ctx.fillStyle = "#02010a";
      ctx.fillRect(0,0,W(),H());
    }
  }

  function draw(){
    drawBackground();

    // Rocks
    for(const r of rocks){
      if(r.hp <= 0) continue;
      const idx = clamp(4 - r.hp, 0, 3);
      const img = IMG?.rocks?.[idx];
      if(img) ctx.drawImage(img, r.x, r.y, r.w, r.h);
    }

    // Bugs
    for(const b of bugs){
      if(!b.alive) continue;

      if(b.glow > 0){
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        drawGlowRing(
          b.x + b.w/2, b.y + b.h/2,
          b.w*0.75,
          clamp(b.glow/0.22, 0, 1),
          "rgba(140,255,210,0.22)"
        );
        ctx.restore();
      }

      if(IMG?.bug1) ctx.drawImage(IMG.bug1, b.x, b.y, b.w, b.h);
    }

    // Boo shots
    for(const s of booShots){
      if(!s.alive) continue;

      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      drawGlowRing(s.x, s.y, 18, 1, "rgba(255,214,102,0.35)");
      ctx.restore();

      ctx.fillStyle = "#fff6d1";
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }

    // Bug shots
    for(const bl of bugShots){
      if(!bl.alive) continue;

      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      drawGlowRing(bl.x, bl.y, bl.r*2.2, 1, "rgba(70,255,140,0.22)");
      ctx.restore();

      ctx.fillStyle = "rgba(70,255,140,0.92)";
      ctx.beginPath();
      ctx.arc(bl.x, bl.y, bl.r, 0, Math.PI*2);
      ctx.fill();
    }

    // Sparkles
    if(sparkles.length){
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      for(const p of sparkles){
        const t = p.life / p.ttl;
        const a = 1 - t;
        ctx.globalAlpha = a;
        ctx.fillStyle = "rgba(255,230,140,0.9)";
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
      ctx.globalAlpha = 1;
    }

    // Slime puffs
    if(slimePuffs.length){
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      for(const p of slimePuffs){
        const t = p.life / p.ttl;
        const a = (1 - t) * 0.6;
        ctx.globalAlpha = a;
        ctx.fillStyle = "rgba(70,255,140,0.6)";
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
      ctx.globalAlpha = 1;
    }

    // Player (glow while shooting)
    const pimg = (player.shootFlash > 0) ? IMG?.booShoot : IMG?.booIdle;

    if(player.glow > 0){
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      drawGlowRing(
        player.x + player.w/2, player.y + player.h/2,
        player.w*0.9,
        clamp(player.glow/0.18, 0, 1),
        "rgba(255,214,102,0.20)"
      );
      ctx.restore();
    }

    if(pimg) ctx.drawImage(pimg, player.x, player.y, player.w, player.h);

    // HUD
    ctx.save();
    ctx.font = "700 14px system-ui, -apple-system, sans-serif";
    ctx.fillStyle = "rgba(255,255,255,0.86)";
    ctx.fillText("BOOHA INVADERS — STAGE 1", 14, 24);
    ctx.font = "600 12px system-ui, -apple-system, sans-serif";
    ctx.fillStyle = "rgba(255,255,255,0.70)";
    ctx.fillText("← → move   SPACE shoot", 14, 42);
    ctx.restore();
  }

  function loop(ts){
    const t = ts/1000;
    const dt = Math.min(0.033, t - last || 0);
    last = t;

    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  async function boot(){
    resize();
    try{
      const [bg, idle, shoot, bug, r1, r2, r3, r4] = await Promise.all([
        loadImg(ASSETS.bg),
        loadImg(ASSETS.booIdle),
        loadImg(ASSETS.booShoot),
        loadImg(ASSETS.bug1),
        loadImg(ASSETS.rocks[0]),
        loadImg(ASSETS.rocks[1]),
        loadImg(ASSETS.rocks[2]),
        loadImg(ASSETS.rocks[3])
      ]);
      IMG = {
        bg,
        booIdle: idle,
        booShoot: shoot,
        bug1: bug,
        rocks: [r1,r2,r3,r4]
      };
    } catch(e){
      console.warn(e);
      IMG = IMG || {};
    }

    resetStage1();
    requestAnimationFrame(loop);
  }

  boot();
})();
</script>
</body>
</html>
