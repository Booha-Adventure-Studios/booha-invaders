<!-- =========================
CHUNK 1 / 3
HEAD + STYLE
(doctype ‚Üí </head>)
========================= -->

<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Booha Invaders ‚Äî Stage 1 DOTTY</title>
<style>
  html,body{
    margin:0;
    height:100%;
    background:#000;
    overflow:hidden;
  }
  canvas{
    display:block;
    width:100vw;
    height:100vh;
    touch-action:none;
  }

/* =========================
   Booha Invaders ‚Äî Start Overlay (CLEAN)
   Black + Pink glow
   JP: white / EN: light green
   START button: gradient + BLACK text
   Everything centered + tighter spacing
   ========================= */

#startOverlay{
  background: rgba(0,0,0,.82);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  color:#ffffff; /* JP default */
}

#startOverlay{
  position: fixed;
  inset: 0;
  z-index: 9999;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 18px;
}

  
  
/* panel (inner div) */
#startOverlay > div{
  background: rgba(0,0,0,.78);
  border: 1px solid rgba(255, 90, 170, .45);
  box-shadow:
    0 0 22px rgba(255, 90, 170, .35),
    0 0 65px rgba(255, 90, 170, .18);
  text-align: center;
  padding: 18px 16px 14px; /* tighter bottom */
}

#startOverlay > div{
  width: min(560px, 92vw);
  border-radius: 18px;
}

  
/* tighten title spacing (JP title + EN title) */
#startOverlay > div > div:nth-child(1){
  margin: 0;
  line-height: 1.15;
}
#startOverlay > div > div:nth-child(2){
  margin-top: 6px;
  line-height: 1.15;
}

/* mission card (3rd child in your overlay panel) */
#startOverlay > div > div:nth-child(3){
  max-width: 520px;
  margin: 12px auto 14px;
  padding: 12px 14px;
  text-align: center;
}

/* list centered + no indent */
#startOverlay ul{
  list-style:none;
  padding:0;
  margin:10px 0 0;
  text-align:center;
}
#startOverlay li{
  margin: 10px 0;
}

/* Japanese bullet headers (b) */
#startOverlay li b{
  display:block;
  color:#ffffff !important;
}

/* English lines: your EN lines use inline opacity styles */
#startOverlay [style*="opacity"]{
  color:#b9ffcf !important;
}

/* Remove the old BGM info lines (if still present) */
#startOverlay [style*="BGM starts"],
#startOverlay [style*="BGM„Åå„ÅØ„Åò„Åæ„Çä„Åæ„Åô"]{
  display:none !important;
}

/* START button: keep gradient + force BLACK text */
#startBtn{
  background: linear-gradient(90deg, rgba(255,126,185,.95), rgba(255,209,102,.98)) !important;
  box-shadow:
    0 0 18px rgba(255, 90, 170, .45),
    0 0 40px rgba(255, 90, 170, .22) !important;
}

#startBtn span{
  color:#000 !important; /* JP + EN inside button always black */
  opacity: 1 !important; /* prevents the EN span opacity from dimming/greening */
}

/* bottom line spacing (your "So many Dotty!") ‚Äî pull closer */
#startOverlay > div > div:last-child{
  margin-top: 10px !important;
  line-height: 1.2;
}

/* === OVERRIDE INLINE ALIGN (Mission / How to play) === */
#startOverlay div[style*="text-align:left"]{
  text-align:center !important;
}

/* === FORCE START BUTTON TEXT BLACK (JP + EN) === */
#startOverlay #startBtn span{
  color:#000 !important;
  opacity:1 !important;
}


  
</style>
</head>

<!-- =========================
END CHUNK 1 / 3
========================= -->

<!-- =========================
CHUNK 2 / 3
BODY + SCRIPT (PART 1)
(<body> ‚Üí mid-script)
========================= -->

<body>
<canvas id="c"></canvas>
<div id="startOverlay" style="position:fixed;inset:0;z-index:9999;display:flex;align-items:center;justify-content:center;padding:18px;background:radial-gradient(1200px 700px at 50% 35%, rgba(255,215,120,.18), rgba(0,0,0,.92));backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);">
  <div style="width:min(680px,92vw);border-radius:22px;padding:18px 16px 16px;background:rgba(0,0,0,.62);border:1px solid rgba(255,255,255,.14);box-shadow:0 0 22px rgba(255,209,102,.20),0 0 60px rgba(255,126,185,.12);text-align:center;font-family:system-ui,-apple-system,'Noto Sans JP',sans-serif;">
    <div style="font-weight:900;font-size:24px;">„Çà„ÅÜ„Åì„ÅùÔºÅ„Éñ„Éº„Éè„Éº„Éª„Ç§„É≥„Éô„Éº„ÉÄ„Éº„Ç∫„Å∏ÔºÅ</div>
    <div style="font-weight:800;font-size:16px;opacity:.9;margin-top:2px;">WELCOME TO BOOHA INVADERS!</div>

    <div style="margin:14px auto 14px;padding:14px;border-radius:18px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);text-align:left;">
      <div style="font-weight:900;font-size:18px;">„Éü„ÉÉ„Ç∑„Éß„É≥ÔºëÔºö„Éâ„ÉÉ„ÉÜ„Ç£</div>
      <div style="font-weight:800;font-size:14px;opacity:.9;margin-top:2px;">Mission 1: Dotty</div>

      <div style="margin-top:10px;font-weight:900;">„ÅÇ„Åù„Å≥„Åã„Åü</div>
      <div style="font-weight:800;font-size:12px;opacity:.85;margin-top:1px;">How to Play</div>

      <ul style="margin:10px 0 0;padding-left:18px;line-height:1.35;font-size:14px;">
        <li style="margin:8px 0;"><b>Â∑¶Âè≥„Å´„ÅÜ„Åî„Åã„Åó„Å¶ „Çà„Åë„Çà„ÅÜÔºÅ</b><div style="opacity:.85;font-size:12px;margin-top:2px;">Drag (mobile) / Arrow keys (desktop)</div></li>
        <li style="margin:8px 0;"><b>„Éñ„Éº„Éè„Éº„ÅØ „Åò„Å©„ÅÜ„Åß „ÅÜ„Å§ÔºÅ</b><div style="opacity:.85;font-size:12px;margin-top:2px;">Booha shoots automatically</div></li>
        <li style="margin:8px 0;"><b>„ÇØ„Ç§„Ç∫„Å´ „Åì„Åü„Åà„Å¶ „Åô„Åô„ÇÇ„ÅÜÔºÅ</b><div style="opacity:.85;font-size:12px;margin-top:2px;">Answer questions to progress</div></li>
        <li style="margin:8px 0;"><b>„ÅÇ„ÇÅ„Çí „Å®„Çã„Å® „Éë„ÉØ„Éº„Ç¢„ÉÉ„ÉóÔºÅ</b><div style="opacity:.85;font-size:12px;margin-top:2px;">Get candy to power up</div></li>
      </ul>
    </div>

    <button id="startBtn" type="button" style="width:min(420px,92vw);border:none;border-radius:999px;padding:14px 18px 12px;cursor:pointer;background:linear-gradient(90deg, rgba(255,126,185,.95), rgba(255,209,102,.98));box-shadow:0 0 18px rgba(255,126,185,.35),0 0 30px rgba(255,209,102,.25);">
      <span style="display:block;font-weight:900;font-size:20px;color:#000;">„Çπ„Çø„Éº„ÉàÔºÅ</span>
      <span style="display:block;font-weight:900;font-size:14px;color:#000;opacity:.9;margin-top:2px;">START!</span>
    </button>

  <div style="margin-top:6px;">
  <div style="font-size:13px;font-weight:700;">
    „Éâ„ÉÉ„ÉÜ„Ç£„ÅåÂ§ö„Åô„Åé„ÇãÔºÅ
  </div>
  <div style="margin-top:2px;font-size:12px;opacity:.85;">
    So many Dotty!
  </div>
</div>

</div> <!-- close panel -->
</div> <!-- close startOverlay -->

<script>
//debugger
window.addEventListener("error", (e)=>{
  document.body.insertAdjacentHTML("beforeend",
    `<div style="position:fixed;left:12px;right:12px;bottom:12px;z-index:99999;
      background:#000c;color:#fff;padding:10px;border-radius:12px;font:12px/1.4 system-ui">
      <b>JS ERROR</b><br>${(e.error && e.error.stack) ? e.error.stack : e.message}
    </div>`
  );
});

window.addEventListener("unhandledrejection", (e)=>{
  document.body.insertAdjacentHTML("beforeend",
    `<div style="position:fixed;left:12px;right:12px;bottom:12px;z-index:99999;
      background:#000c;color:#fff;padding:10px;border-radius:12px;font:12px/1.4 system-ui">
      <b>PROMISE ERROR</b><br>${e.reason && e.reason.stack ? e.reason.stack : e.reason}
    </div>`
  );
});
//debugger
// =======================
// CHUNK A ‚Äî GLOBALS + RESIZE + FIRING (ANTI-SPRAY FINAL)
// - NO tap shooting
// - Auto fire ONLY when fully still
// - Boost shots are handled HERE (not inside update())
// =======================

// globals
let booFireTimer = 0;

// true globals (do NOT put on player)
let booAutoCD = 0;   // normal cadence cooldown
let booPinkCD = 0;   // boost cadence cooldown (pink)

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { alpha:false });

// -----------------------
// DPR / resize
// -----------------------
const DPR_CAP = 2;
let DPR = 1;

function resize(){
  DPR = Math.min(window.devicePixelRatio || 1, DPR_CAP);
  canvas.width  = Math.floor(innerWidth * DPR);
  canvas.height = Math.floor(innerHeight * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0); // draw in CSS px
}
addEventListener("resize", resize);

// -----------------------
// Auto firing (movement-locked) + boost lives here
// -----------------------
function updateFiring(dt){
  // keep booFireTimer alive for the draw() shooting pose
  booFireTimer = Math.max(0, booFireTimer - dt);

  if(!started) return;
  if(player.energy <= 0) return;
  if(quizOpen) return;

  // tick cooldowns
  booAutoCD = Math.max(0, booAutoCD - dt);
  booPinkCD = Math.max(0, booPinkCD - dt);

  // ‚úÖ stand-still rule (hard lock)
  if(playerMoving) return;
  if(shootResumeDelay > 0) return;

  // ‚úÖ boost = pink mode (0..3)
  const stack = clamp((player.boost || 0), 0, 3);
  const isPink = (stack > 0);

  // -------------------------
  // NORMAL (gold): one shot at a time, slow cadence
  // -------------------------
  if(!isPink){
    if(!canFireNormal()) return;
    if(booAutoCD > 0) return;

    fireBooShot(false);
    booFireTimer = 0.12;

    // ‚úÖ main ‚Äúno spray‚Äù knob
    booAutoCD = 0.30;
    return;
  }

  // -------------------------
  // BOOST (pink): still locked to stand-still + settle
  // and limited max shots so it can't flood the screen
  // -------------------------
  const maxPinkShots = [0, 1, 2, 3][stack];      // ‚úÖ hard cap
  const cdPink = clamp(0.22 - 0.03*(stack-1), 0.14, 0.30);

  if(booPinkCD > 0) return;
  if(booShots.length >= maxPinkShots) return;

  fireBooShot(true);
  booFireTimer = 0.12;
  booPinkCD = cdPink;
}


  
  // -----------------------
  // Assets (folders)
  // -----------------------
  const ASSETS = {
    bg:       "assets/background.png",
    booIdle:  "assets/booha-invad-1.png",
    booShoot: "assets/booha-invad-2.png",
    bug:      "assets/bug-1.png",
    candy:    "assets/candy.png",
    rocks: [
      "assets/rock1.png",
      "assets/rock2.png",
      "assets/rock3.png",
      "assets/rock4.png"
    ]
  };

  function loadImg(src){
    return new Promise((res, rej)=>{
      const img = new Image();
      img.onload = ()=>res(img);
      img.onerror = ()=>rej(new Error("Failed to load: " + src));
      img.src = src;
    });
  }

  const IMG = {};

  // -----------------------
  // Helpers
  // -----------------------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand  = (a,b)=>a + Math.random()*(b-a);

  function aabb(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  // cover background (no distortion)
  function drawCover(img){
    const W = innerWidth, H = innerHeight;
    const iw = img.width, ih = img.height;
    const s = Math.max(W/iw, H/ih);
    const dw = iw*s, dh = ih*s;
    const dx = (W - dw)/2;
    const dy = (H - dh)/2;
    ctx.drawImage(img, dx, dy, dw, dh);
  }

  // -----------------------
  // Question Popup (Multiple Choice 1‚Äì100)
  // ‚úÖ SINGLE SOURCE OF TRUTH (declare ONCE here)
  // -----------------------
  let quizOpen  = false;
  let quizCount = 0;        // completed questions (Dotty scaling)
  let quizDeck  = [];
  let quizPos   = 0;
  let quizQ     = null;     // { n, choices:[...], correctIndex }

  // -----------------------
  // Quiz helpers (1‚Äì100 multiple choice)
  // -----------------------
  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j = (Math.random()*(i+1))|0;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  const ONES  = ["zero","one","two","three","four","five","six","seven","eight","nine"];
  const TEENS = ["ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen"];
  const TENS  = ["","","twenty","thirty","forty","fifty","sixty","seventy","eighty","ninety"];

  function numberToWords(n){
    if(n < 10) return ONES[n];
    if(n < 20) return TEENS[n-10];
    const t = (n/10)|0;
    const o = n % 10;
    if(o === 0) return TENS[t];
    return TENS[t] + "-" + ONES[o];
  }

  function splitDigitsWords(n){
    const t = (n/10)|0;
    const o = n % 10;
    return ONES[t] + " " + ONES[o]; // "two eight"
  }

  function twoEightyStyle(n){
    const t = (n/10)|0;
    return ONES[t] + "-" + TENS[t]; // "two-eighty"
  }

  function punChoice(n){
    const H = { one:"won", two:"too", four:"for", eight:"ate", zero:"oh" };
    if(n >= 10){
      const t = (n/10)|0;
      const o = n % 10;
      const a = H[ONES[t]] || ONES[t];
      const b = H[ONES[o]] || ONES[o];
      return a + "-" + b; // "too-ate"
    }
    const w = ONES[n];
    return (H[w] || ("the-" + w));
  }

  function makeQuestion(n){
    const correct = numberToWords(n);

    // 3 wrongs (intentionally a little silly)
    let wrong1, wrong2, wrong3;

    if(n >= 10){
      wrong1 = splitDigitsWords(n);
      wrong2 = twoEightyStyle(n);
      wrong3 = punChoice(n);
    } else {
      wrong1 = "the " + ONES[n];
      wrong2 = ONES[n] + "-" + ONES[n];
      wrong3 = punChoice(n);
    }

    // de-dupe + ensure not equal to correct
    const pool = [];
    for(const w of [wrong1, wrong2, wrong3]){
      if(!w) continue;
      if(w === correct) continue;
      if(pool.includes(w)) continue;
      pool.push(w);
    }
    while(pool.length < 3){
      const w = TENS[2 + ((Math.random()*8)|0)] + "-" + ONES[(Math.random()*10)|0];
      if(w !== correct && !pool.includes(w)) pool.push(w);
    }

    const choices = [correct, pool[0], pool[1], pool[2]];
    shuffle(choices);
    return { n, choices, correctIndex: choices.indexOf(correct) };
  }

  function buildQuizDeck(){
    quizDeck = [];
    for(let n=1;n<=100;n++) quizDeck.push(n);
    shuffle(quizDeck);
    quizPos = 0;
  }

  function nextQuiz(){
    if(!quizDeck.length) buildQuizDeck();
    if(quizPos >= quizDeck.length){
      shuffle(quizDeck);
      quizPos = 0;
    }
    const n = quizDeck[quizPos++];
    quizQ = makeQuestion(n);
  }

  // -----------------------
  // NOTE: Quiz overlay drawing DOES NOT belong in Chunk 2 update section.
  // Keeping your code (not deleting) but wrapping it so it doesn't run here.
  // Chunk 3 will call drawQuizOverlay() from inside draw().
  // -----------------------
  function drawQuizOverlay(){
// =========================
// QUIZ OVERLAY (Multiple Choice) ‚úÖ shows red/green + message
// =========================
if(quizOpen && quizQ){
  ctx.save();

  // dim + vignette
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(0,0,innerWidth,innerHeight);

  const cx = innerWidth/2, cy = innerHeight/2;
  const r0 = Math.min(innerWidth, innerHeight) * 0.22;
  const r1 = Math.min(innerWidth, innerHeight) * 0.80;
  const vg = ctx.createRadialGradient(cx, cy, r0, cx, cy, r1);
  vg.addColorStop(0, "rgba(0,0,0,0)");
  vg.addColorStop(1, "rgba(0,0,0,0.65)");
  ctx.fillStyle = vg;
  ctx.fillRect(0,0,innerWidth,innerHeight);

  // Big number
  const q = String(quizQ.n);
  ctx.fillStyle = "rgba(255,255,255,0.96)";
  ctx.font = "900 72px system-ui, -apple-system, sans-serif";
  const qw = ctx.measureText(q).width;
  ctx.fillText(q, innerWidth/2 - qw/2, innerHeight*0.34);

  // Buttons layout (must match hit-test)
  const btnW = clamp(innerWidth*0.72, 260, 560);
  const btnH = 54;
  const gap = 14;
  const startY = innerHeight*0.42;
  const x = innerWidth/2 - btnW/2;

  ctx.font = "800 20px system-ui, -apple-system, sans-serif";

  for(let i=0;i<4;i++){
    const y = startY + i*(btnH+gap);

    // ‚úÖ state colors
    const isCorrect = (quizSolved && i === quizQ.correctIndex);
    const isWrong   = (quizTried && quizTried[i]);

    let fill = "rgba(255,255,255,0.10)";
    let stroke = "rgba(255,255,255,0.22)";

    if(isWrong){
      fill = "rgba(255,60,90,0.22)";
      stroke = "rgba(255,60,90,0.55)";
    }
    if(isCorrect){
      fill = "rgba(60,255,140,0.22)";
      stroke = "rgba(60,255,140,0.65)";
    }

    ctx.fillStyle = fill;
    ctx.fillRect(x, y, btnW, btnH);

    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, btnW, btnH);

    const label = (i+1) + ")  " + quizQ.choices[i];
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.fillText(label, x + 16, y + 36);
  }

  // Hint
  ctx.font = "700 14px system-ui, -apple-system, sans-serif";
  ctx.fillStyle = "rgba(255,255,255,0.75)";
  const hint = "Tap an answer or press 1‚Äì4";
  const hw = ctx.measureText(hint).width;
  ctx.fillText(hint, innerWidth/2 - hw/2, startY + 4*(btnH+gap) + 12);

  // ‚úÖ Message (JP)
  if(typeof quizMsg === "string" && quizMsg){
    ctx.font = "900 16px system-ui, -apple-system, sans-serif";
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    const mw = ctx.measureText(quizMsg).width;
    ctx.fillText(quizMsg, innerWidth/2 - mw/2, startY + 4*(btnH+gap) + 38);
  }

  ctx.restore();
} // ‚úÖ closes: if(quizOpen && quizQ)

} // ‚úÖ closes: function drawQuizOverlay()



  // -----------------------
  // Input (universal)
  // -----------------------
  let pointerDown = false;
  let pointerX = null;

canvas.addEventListener("pointerdown", (e)=>{
  // ‚úÖ QUIZ: tap an answer (do not start dragging)
  if(quizOpen){
    const idx = quizHitTest(e.clientX, e.clientY);
    if(idx >= 0) answerQuiz(idx);
    return;
  }

 
    e.preventDefault();
    pointerDown = true;
    pointerX = e.clientX;
    try { canvas.setPointerCapture(e.pointerId); } catch(_) {}
  }, { passive:false });

  canvas.addEventListener("pointermove", (e)=>{
    if(!pointerDown) return;
    e.preventDefault();
    pointerX = e.clientX;
  }, { passive:false });

  canvas.addEventListener("pointerup", (e)=>{
    pointerDown = false;
    pointerX = null;
    try { canvas.releasePointerCapture(e.pointerId); } catch(_) {}
  });

  canvas.addEventListener("pointercancel", (e)=>{
    pointerDown = false;
    pointerX = null;
    try { canvas.releasePointerCapture(e.pointerId); } catch(_) {}
  });

  addEventListener("mousemove", (e)=>{
    // Desktop: ignore mouse unless dragging
    if(!pointerDown) return;
    pointerX = e.clientX;
  });

  const keys = new Set();
  addEventListener("keydown", (e)=>{
    if(e.key === "ArrowLeft" || e.key === "ArrowRight"){
      e.preventDefault();
      pointerX = null; // ‚úÖ keyboard takes control
    }
    keys.add(e.key);
  }, {passive:false});

  addEventListener("keyup", (e)=>keys.delete(e.key));

  // -----------------------
  // Entities
  // -----------------------
  const player = {
  x:0, y:0, w:80, h:80,
  energy: 100,
  glow: 0,
  sugar: 0,
  hitIFrames: 0,
  boost: 0
};


  const rocks = [];     // {x,y,w,h,hp}
  const bugs  = [];     // {x,y,w,h,alive, enterT, enterDur, tx,ty, bob, driftSpeed, fireCD, glow}
  const booShots = [];  // {x,y,vy,color,isPink,dead}
  const bugShots = [];  // {x,y,vx,vy,r,dead,t}
  const sparkles = [];  // {x,y,vx,vy,life,ttl,size,kind}
  const candies  = [];  // {x,y,vx,vy,spin,dead}

  // -----------------------
  // Question Popup (Multiple Choice 1‚Äì100)
  // (kept as-is from your file, but fixed to NOT redeclare)
  // -----------------------
  // let quizOpen = false;
  // let quizCount = 0;
  // let quizDeck = [];
  // let quizPos = 0;
  // let quizQ = null;

// -----------------------
// Waves / pacing (FINAL)
// 2s wait -> WAVE card -> 4 groups -> quiz -> next wave
// Easy to edit: only change WAVE_TIERS + WAVE_SCALE
// -----------------------

// 4-group patterns per wave tier (EDIT THESE)
const WAVE_TIERS = [
  { from:  1, to:  5,  groups: [ 1,  2,  4,  5] },
  { from:  6, to: 15,  groups: [10, 12, 14, 16] },
  { from: 16, to: 25,  groups: [18, 20, 22, 26] },
  { from: 26, to: 35,  groups: [28, 30, 32, 36] },
  { from: 36, to: 45,  groups: [38, 40, 42, 46] },
  { from: 46, to: 55,  groups: [48, 50, 52, 58] },
  // add more tiers anytime (50+ waves supported)
];

// Difficulty scaling knobs (EDIT THESE)
const WAVE_SCALE = {
  introDelaySec: 2.0,     // after start click, before WAVE 1 card
  waveCardSec: 4.8,      // how long ‚ÄúWAVE N ‚Äî get ready!‚Äù shows

  spawnIntervalBase: 0.60,
  spawnIntervalMin:  0.12,
  spawnIntervalDropPerWave: 0.012,

  driftBase: 8,
  driftGainPerWave: 0.55,
  driftMax: 40,

  fireCooldownBase: 3.6,
  fireCooldownMin:  0.55,
  fireCooldownDropPerWave: 0.08,

  shootersBase: 1,
  shootersGainEveryNWaves: 5,
  shootersMax: 10,
};

const WaveState = {
  wave: 1,
  groupIdx: 0,        // 0..3
  targetCount: 0,
  spawned: 0,
  killed: 0,
  spawnTimer: 0,
  phase: "intro",     // intro | card | run | quiz
  phaseT: 0
};

const BOSS_EVERY_N_WAVES = 5;

function isBossWave(w){
  return (w % BOSS_EVERY_N_WAVES) === 0;
}

const BossState = {
  active: false,
  hp: 0,
  maxHp: 0,
  enterT: 0,
  phaseT: 0
};
  

function tierForWave(n){
  for(const t of WAVE_TIERS){
    if(n >= t.from && n <= t.to) return t;
  }
  return WAVE_TIERS[WAVE_TIERS.length - 1];
}

function groupCountForWave(wave, groupIdx){
  const tier = tierForWave(wave);
  return tier.groups[groupIdx] ?? tier.groups[tier.groups.length-1];
}

function waveSpawnInterval(wave){
  const v = WAVE_SCALE.spawnIntervalBase - WAVE_SCALE.spawnIntervalDropPerWave*(wave-1);
  return clamp(v, WAVE_SCALE.spawnIntervalMin, 99);
}
function waveDriftSpeed(wave){
  const v = WAVE_SCALE.driftBase + WAVE_SCALE.driftGainPerWave*(wave-1);
  return clamp(v, 0, WAVE_SCALE.driftMax);
}
function waveFireCooldown(wave){
  const v = WAVE_SCALE.fireCooldownBase - WAVE_SCALE.fireCooldownDropPerWave*(wave-1);
  return clamp(v, WAVE_SCALE.fireCooldownMin, 99);
}
function waveShooterCap(wave){
  const add = Math.floor((wave-1) / WAVE_SCALE.shootersGainEveryNWaves);
  return clamp(WAVE_SCALE.shootersBase + add, 1, WAVE_SCALE.shootersMax);
}

function startWave(n){
  WaveState.wave = n;
  WaveState.groupIdx = 0;
  WaveState.phaseT = 0;

  if(isBossWave(n)){
    WaveState.phase = "boss";
    BossState.active = true;
    BossState.maxHp = 60;     // tweak later
    BossState.hp = BossState.maxHp;
    BossState.enterT = 0;
    BossState.phaseT = 0;

    // clear normal bugs/shots if you want a clean boss arena
    bugs.length = 0;
    bugShots.length = 0;
    booShots.length = 0;

    return; // do NOT beginGroup()
  }

  WaveState.phase = "intro";
  beginGroup();
}


function beginGroup(){
  WaveState.spawned = 0;
  WaveState.killed = 0;
  WaveState.targetCount = groupCountForWave(WaveState.wave, WaveState.groupIdx);
  WaveState.spawnTimer = 0;
}

function advanceGroupOrQuiz(){
  WaveState.groupIdx++;

  // After 4th group ‚Üí open quiz and STOP
  if(WaveState.groupIdx >= 4){
    WaveState.phase = "quiz";
    quizOpen = true;
    nextQuiz();     // show quiz popup
    return;         // freeze everything
  }

  // Otherwise, start next group in the same wave
  beginGroup();
}


function nextWave(){
  startWave(WaveState.wave + 1);
}

// Call this every frame (dt in seconds)
function updateWaveSystem(dt){
  // --- dt safety (prevents NaN freezing your whole game) ---
  dt = Number(dt);
  if(!Number.isFinite(dt) || dt <= 0) dt = 1/60;       // fallback
  if(dt > 0.05) dt = 0.05;                              // clamp huge frame jumps

  // --- lazy init: if nothing started yet, start Wave 1 ---
  if(!WaveState || !WAVE_SCALE) return;
  if(WaveState.wave == null || WaveState.wave < 1) WaveState.wave = 1;
  if(WaveState.phase == null) WaveState.phase = "intro";
  if(!Number.isFinite(WaveState.phaseT)) WaveState.phaseT = 0;

  // Ensure the very first group has a targetCount set
 if(WaveState.phase === "run" && (WaveState.targetCount == null || WaveState.targetCount <= 0)){
  beginGroup();
}


  WaveState.phaseT += dt;

  // ‚úÖ BOSS PHASE: wave system should not spawn groups or trigger quiz
if(WaveState.phase === "boss"){
  return;
}

  // --- intro: wait after start click ---
  if(WaveState.phase === "intro"){
    if(WaveState.phaseT >= WAVE_SCALE.introDelaySec){
      WaveState.phase = "card";
      WaveState.phaseT = 0;
      // showWaveCard(WaveState.wave)
    }
    return;
  }

  // --- card: show ‚ÄúWAVE N ‚Äî get ready!‚Äù ---
  if(WaveState.phase === "card"){
    if(WaveState.phaseT >= WAVE_SCALE.waveCardSec){
      WaveState.phase = "run";
      WaveState.phaseT = 0;
      WaveState.spawnTimer = 0; // spawn immediately when run begins
      // hideWaveCard()
    }
    return;
  }

  // --- quiz: pause spawns until quiz closes ---
  if(WaveState.phase === "quiz"){
    // When your quiz closes, set quizOpen = false.
    // This will auto-continue to the next wave.
    if(typeof quizOpen !== "undefined" && quizOpen === false){
      if(typeof nextWave === "function") nextWave();
    }
    return;
  }

  // --- run: spawn this group, then wait until it‚Äôs cleared ---
  if(WaveState.spawned < WaveState.targetCount){
    WaveState.spawnTimer -= dt;
    if(WaveState.spawnTimer <= 0){
      spawnBug();
      WaveState.spawned++;
      WaveState.spawnTimer = waveSpawnInterval(WaveState.wave);
    }
  }

 // group cleared ‚Üí advance to next group or quiz
// ‚úÖ do NOT advance if targetCount is 0 (boss / pause states)
if (WaveState.targetCount > 0 && WaveState.killed >= WaveState.targetCount){
  advanceGroupOrQuiz();
}   // ‚Üê closes the IF

}   // ‚Üê closes updateWaveSystem(dt)



// -----------------------
// DOTTY placement (NO OVERLAP)
// -----------------------
function canPlaceTarget(tx, ty, bw, bh){
  const minDX = bw * 0.92;
  const minDY = bh * 0.55;

  for(const b of bugs){
    if(!b.alive) continue;
    const ox = (b.tx ?? b.x);
    const oy = (b.ty ?? b.y);
    if(Math.abs(tx - ox) < minDX && Math.abs(ty - oy) < minDY) return false;
  }
  return true;
}

function pickTargetSlot(bw, bh){
  const lanes = 6;
  const laneW = innerWidth / lanes;

  const baseY = clamp(innerHeight*0.18, 90, 150);
  const rows = [ baseY, baseY + bh*0.75, baseY + bh*1.5 ];

  for(let tries=0; tries<24; tries++){
    const lane = (Math.random()*lanes)|0;
    const baseX = lane*laneW + laneW/2 - bw/2;
    const row = rows[(Math.random()*rows.length)|0];
    const ty = row + rand(0, 20);

    const wiggle = laneW * 0.18;
    const tx = baseX + rand(-wiggle, wiggle);

    if(canPlaceTarget(tx, ty, bw, bh)) return { tx, ty };
  }

  for(const row of rows){
    for(let lane=0; lane<lanes; lane++){
      const tx = lane*laneW + laneW/2 - bw/2;
      const ty = row;
      if(canPlaceTarget(tx, ty, bw, bh)) return { tx, ty };
    }
  }

  return { tx: innerWidth*0.5 - bw*0.5, ty: rows[rows.length-1] };
}

  
const DOTTY_SHIELD_POST = 2.0; // seconds AFTER arriving

  function spawnBug(){
    const lanes = 6;
    const laneW = innerWidth / lanes;

    const bw = clamp(innerWidth * 0.078, 54, 78); // ~20% larger than earlier
    const bh = bw;

 const slot = pickTargetSlot(bw, bh);
const tx = slot.tx;
const ty = slot.ty;


    const startX = tx + rand(-laneW*0.35, laneW*0.35);
    const startY = -bh - rand(30, 130);

   bugs.push({
  x: startX,
  y: startY,
  w: bw,
  h: bh,
  alive: true,

  // elegant entry
  enterT: 0,
  enterDur: rand(0.9, 1.3),
  shieldT: 0,
  hasShotOnce: false,   // ‚Üê ADD THIS
  sx: startX,
  sy: startY,
  tx, ty,

  bob: rand(0, 10),
  driftSpeed: waveDriftSpeed(WaveState.wave),
  fireCD: rand(
    waveFireCooldown(WaveState.wave) * 0.75,
    waveFireCooldown(WaveState.wave) * 1.10
  ),

  glow: 0
});


const b = bugs[bugs.length - 1];
b.shieldT = b.enterDur + DOTTY_SHIELD_POST;
    
  }

  function easeInCubic(t){ return t*t*t; }
  function easeInOutSine(t){ return -(Math.cos(Math.PI * t) - 1) / 2; }


  function easeOutCubic(t){
  return 1 - Math.pow(1 - t, 3);
}

  // -----------------------
  // FX
  // -----------------------
  function addSpark(x,y, n=3, kind="gold"){
    for(let i=0;i<n;i++){
      sparkles.push({
        x, y,
        vx: rand(-120,120),
        vy: rand(-160,60),
        life: 0,
        ttl: rand(0.18, 0.34),
        size: rand(1.2, 2.6),
        kind
      });
    }
  }

  function dropCandy(){
    candies.push({
      x: rand(40, innerWidth-40),
      y: -30,
      vx: rand(-20, 20),
      vy: rand(70, 90),
      spin: rand(-2, 2),
      dead:false
    });
  }

  // -----------------------
  // Shooting rules
  // -----------------------
  // Normal: GOLD sparkly, one shot at a time (wait until clear)
  // Sugar:  PINK rapid shots + pink pulsate

  function canFireNormal(){
    // one-shot-at-a-time
    return booShots.length === 0;
  }

  function fireBooShot(isPink){
    booShots.push({
      x: player.x + player.w/2,
      y: player.y + 6,
      vy: isPink ? -1050 : -900,
      isPink,
      dead:false
    });

    // subtle glow when shooting (smaller)
    player.glow = isPink ? 0.10 : 0.12;
  }

  function fireBugShot(b){
    bugShots.push({
      x: b.x + b.w/2,
      y: b.y + b.h + 8,
      vx: rand(-55, 55),
      vy: rand(260, 340),
      r: rand(7, 10),
      t: 0,
      dead:false
    });
    b.glow = 0.18;
  }

 // -----------------------
// Update  ‚úÖ candy interval + candy-powered shots after 10 quizzes
// -----------------------
let last = 0;
let started = false;
let stageTime = 0;

let lastPlayerX = 0;
let playerMoving = false;
let shootResumeDelay = 0; // seconds


// Candy interval timer
let candyTimer = 10; // first drop happens ~10s in (tweak if you want)

function update(dt){
  if(player.energy <= 0) return;

stageTime += dt;

// drift ramps slowly (gentle -> faster)
const driftBase = 10;
const driftRamp = clamp((stageTime - 18) / 40, 0, 1);
const driftNow  = driftBase + driftRamp * 28;

// --------------------
// MOVEMENT (first)
// --------------------
const prevX = player.x;

if(pointerX !== null){
  player.x = clamp(pointerX - player.w/2, 10, innerWidth - player.w - 10);
} else {
  if(keys.has("ArrowLeft")  || keys.has("a") || keys.has("A")) player.x -= 420*dt;
  if(keys.has("ArrowRight") || keys.has("d") || keys.has("D")) player.x += 420*dt;
  player.x = clamp(player.x, 10, innerWidth - player.w - 10);
}

// --------------------
// MOVEMENT LOCK (after movement)
// --------------------
const dx = Math.abs(player.x - prevX);
const moved = (dx > 0.35);

if(moved){
  playerMoving = true;

  // 0.3ish penalty after ANY movement
  shootResumeDelay = 0.30;

  // also hard-penalize cooldowns (prevents tap-move spray)
  booAutoCD = Math.max(booAutoCD, 0.30);
  booPinkCD = Math.max(booPinkCD, 0.30);
} else {
  playerMoving = false;
  shootResumeDelay = Math.max(0, shootResumeDelay - dt);
}

  // timers
player.glow = Math.max(0, player.glow - dt*2.2);
player.sugar = Math.max(0, player.sugar - dt); // legacy (ok to leave)
player.hitIFrames = Math.max(0, player.hitIFrames - dt);

// üç¨ candy timer
candyTimer -= dt;
if(candyTimer <= 0 && candies.length === 0){
  dropCandy();
  candyTimer = rand(8, 12); // next drop window
}


// bugs update (enter + drift + shooting)
for(const b of bugs){
  if(!b.alive) continue;

  // shield timer counts down always
  b.shieldT = Math.max(0, b.shieldT - dt);

  b.glow = Math.max(0, b.glow - dt*2.0);
  b.bob += dt;

  // entry
  if(b.enterT < b.enterDur){
    b.enterT += dt;
    const t = clamp(b.enterT / b.enterDur, 0, 1);

    const curve = Math.sin(t*Math.PI) * (innerWidth*0.015) * (Math.random()<0.5?-1:1);
    b.x = b.sx + (b.tx - b.sx)*easeOutCubic(t) + curve*(1-t);
    b.y = b.sy + (b.ty - b.sy)*easeInOutSine(t);

  } else {

    // drift (gentle, then faster) + Boost 3 reaction
    let driftMult = 1;
    if(player.boost >= 3) driftMult = 1.6;

    b.driftSpeed = driftNow * driftMult;
    b.x = b.tx + Math.sin(b.bob*0.9) * b.driftSpeed;
    b.y = b.ty + Math.cos(b.bob*1.1) * (b.driftSpeed*0.32);

    // firing (starts calm, ramps with time) + Boost 3 reaction
    const fireRamp = clamp((stageTime - 12) / 40, 0, 1);
    let base = 3.4 - fireRamp*1.6;
    if(player.boost >= 3) base *= 0.6;

    // ‚úÖ shield ended ‚Üí MUST shoot once
    if(b.shieldT === 0 && !b.hasShotOnce){
      fireBugShot(b);
      b.hasShotOnce = true;

      // schedule the next normal shot
      b.fireCD = rand(base, base + 1.0);
      b.fireCD = Math.max(0.6, b.fireCD);
    }

    // no normal firing while shielded / before first shot
    if(b.shieldT > 0 || !b.hasShotOnce) continue;

    // normal cadence
    b.fireCD -= dt;
    if(b.fireCD <= 0){
      fireBugShot(b);
      b.fireCD = rand(base, base + 1.0);
      b.fireCD = Math.max(0.6, b.fireCD);
    }
  }
}

 
} // ‚úÖ CLOSE update(dt) ‚Äî this was missing

function updateProjectiles(dt){

    // boo shots
    for(const s of booShots){
      if(s.dead) continue;
      s.y += s.vy * dt;

      // sparkly trail
      if(s.isPink){
        addSpark(s.x + rand(-2,2), s.y + 10 + rand(-2,2), 2, "pink");
      } else {
        addSpark(s.x + rand(-2,2), s.y + 10 + rand(-2,2), 2, "gold");
      }

      // hit bugs
      for(const b of bugs){
        if(!b.alive) continue;
        if(aabb(s.x-5, s.y-10, 10, 18, b.x, b.y, b.w, b.h)){

  // SHIELD: block the hit (shot disappears + sparkles)
  if(b.shieldT > 0){
  s.dead = true;
  addSpark(b.x + b.w/2, b.y + b.h/2, 24, "gold"); // BIG obvious burst
  break;
}


  // normal kill
  b.alive = false;
  s.dead = true;
  WaveState.killed++;

  addSpark(b.x+b.w/2, b.y+b.h/2, 14, s.isPink ? "pink":"gold");
  break;
}

      }

      // offscreen
      if(s.y < -40) s.dead = true;
    }

    // bug shots (green blobs)
    for(const bl of bugShots){
      if(bl.dead) continue;
      bl.t += dt;
      const wob = Math.sin(bl.t*6) * 0.8;

      bl.x += (bl.vx * (1+wob)) * dt;
      bl.y += bl.vy * dt;

      // hit rocks
      for(const r of rocks){
        if(r.hp <= 0) continue;
        if(aabb(bl.x-bl.r, bl.y-bl.r, bl.r*2, bl.r*2, r.x, r.y, r.w, r.h)){
          r.hp = Math.max(0, r.hp - 1);
          bl.dead = true;
          // a little slime puff via sparkles in green
          addSpark(bl.x, bl.y, 8, "slime");
          break;
        }
      }

      // hit player (with i-frames)
// hit player (with i-frames)
if(!bl.dead && player.hitIFrames <= 0){
  if(aabb(bl.x-bl.r, bl.y-bl.r, bl.r*2, bl.r*2, player.x, player.y, player.w, player.h)){
    bl.dead = true;

    // damage
    player.energy = Math.max(0, player.energy - 10);
    player.hitIFrames = 0.55;

    // ‚úÖ RESET BOOST STACKS ON HIT
    player.boost = 0;

    // visual feedback
    addSpark(player.x+player.w/2, player.y+player.h/2, 12, "slime");
  }
}

      if(bl.y > innerHeight + 80) bl.dead = true;
    }

    // cleanup arrays (real cleanup, not a no-op)
    for(let i=booShots.length-1;i>=0;i--){
      if(booShots[i].dead) booShots.splice(i,1);
    }
    for(let i=bugShots.length-1;i>=0;i--){
      if(bugShots[i].dead) bugShots.splice(i,1);
    }
    for(let i=bugs.length-1;i>=0;i--){
      if(!bugs[i].alive) bugs.splice(i,1);
    }
  }

 function updateCandy(dt){
  for(const c of candies){
    if(c.dead) continue;
    c.x += c.vx * dt;
    c.y += c.vy * dt;

    // sparkle as it falls
    addSpark(c.x + rand(-6,6), c.y + rand(-6,6), 1, "pink");

    // catch
    if(aabb(c.x-18, c.y-18, 36, 36, player.x, player.y, player.w, player.h)){
      c.dead = true;

      // ‚úÖ BOOST STACKS (persist until hit)
      // 1 candy = +1 stack, 2 candies = +2 stacks, capped at 3
      player.boost = clamp((player.boost || 0) + 1, 0, 3);
      new Audio("candy-get.mp3").play().catch(()=>{});


      // small restore (keep this)
      player.energy = Math.min(100, player.energy + 30);

      // turn off old timer-based sugar (so boost is the only system)
      player.sugar = 0;

      // little pulse
      player.glow = 0.12;
    }

    if(c.y > innerHeight + 60) c.dead = true;
  }

  for(let i=candies.length-1;i>=0;i--){
    if(candies[i].dead) candies.splice(i,1);
  }
}


  function updateParticles(dt){
    for(const p of sparkles){
      p.life += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 280 * dt;
    }
    for(let i=sparkles.length-1;i>=0;i--){
      if(sparkles[i].life >= sparkles[i].ttl) sparkles.splice(i,1);
    }
  }


  /* =========================
  END CHUNK 2 / 3
  (stop here ‚Äì logic & updates above)
  ========================= */


/* =========================
CHUNK 3 / 3
SCRIPT (PART 2) + END
(Draw ‚Üí </html>)
========================= */

  // -----------------------
  // Draw
  // -----------------------

  function drawGlow(x,y,r,alpha,color){
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  


// -----------------------
// WAVE BANNER (ROLL ACROSS) ‚úÖ SIMPLE + SAFE
// Shows ONLY during WaveState.phase === "card"
// -----------------------
function drawWaveBanner(){
  if(!started) return;
  if(!WaveState || WaveState.phase !== "card") return;

  // total duration of the card phase
  const dur = Math.max(0.001, (WAVE_SCALE && WAVE_SCALE.waveCardSec) ? WAVE_SCALE.waveCardSec : 4.8);

  // timing: slow entrance + pause + fast exit
  const pauseSec = 1.0;                         // ‚Üê center pause length
  const moveSec  = Math.max(0.001, dur - pauseSec);
  const enterSec = moveSec * 0.72;              // ‚Üê slower entrance
  const exitSec  = Math.max(0.001, moveSec - enterSec); // ‚Üê faster exit

  const t = clamp(WaveState.phaseT, 0, dur);

  // p = 0..1 travel progress
  let p = 0;

  if(t < enterSec){
    const u = clamp(t / enterSec, 0, 1);
    p = 0.5 * easeOutCubic(u);                  // arrive into center
  } else if(t < enterSec + pauseSec){
    p = 0.5;                                    // hold in center
  } else {
    const u = clamp((t - enterSec - pauseSec) / exitSec, 0, 1);
    p = 0.5 + 0.5 * easeInCubic(u);             // exit quickly
  }

  const text = "WAVE " + WaveState.wave;
  const sub  = "„Éâ„ÉÉ„ÉÜ„Ç£„Åå „Åè„Çã„ÇàÔºÅ";

  ctx.save();

  const bigSize = clamp(innerWidth * 0.10, 52, 110);
  const subSize = clamp(innerWidth * 0.035, 16, 28);

  ctx.font = "900 " + bigSize + "px system-ui, -apple-system, sans-serif";
  const tw = ctx.measureText(text).width;

  ctx.font = "900 " + subSize + "px system-ui, -apple-system, sans-serif";
  const sw = ctx.measureText(sub).width;

  const margin = Math.max(40, innerWidth * 0.08);
  const travel = innerWidth + margin*2 + Math.max(tw, sw);
  const x = innerWidth + margin - p * travel;
  const y = innerHeight * 0.34;

  ctx.globalCompositeOperation = "lighter";
  drawGlow(x + tw/2, y - bigSize*0.35, bigSize*0.95, 0.22, "rgba(255,120,220,0.55)");
  drawGlow(x + tw/2, y - bigSize*0.35, bigSize*0.85, 0.20, "rgba(255,214,102,0.55)");
  ctx.globalCompositeOperation = "source-over";

  ctx.font = "900 " + bigSize + "px system-ui, -apple-system, sans-serif";
  ctx.lineWidth = 6;
  ctx.strokeStyle = "rgba(0,0,0,0.55)";
  ctx.strokeText(text, x, y);
  ctx.fillStyle = "rgba(255,255,255,0.96)";
  ctx.fillText(text, x, y);

  ctx.font = "900 " + subSize + "px system-ui, -apple-system, sans-serif";
  ctx.lineWidth = 4;
  ctx.strokeStyle = "rgba(0,0,0,0.55)";
  ctx.strokeText(sub, x + (tw - sw)/2, y + subSize*1.2);
  ctx.fillStyle = "rgba(185,255,207,0.92)";
  ctx.fillText(sub, x + (tw - sw)/2, y + subSize*1.2);

  ctx.restore();
}


  
  function draw(){
    // background
    if(IMG.bg) drawCover(IMG.bg);
    else {
      ctx.fillStyle = "#050014";
      ctx.fillRect(0,0,innerWidth,innerHeight);
    }

    // rocks
    for(const r of rocks){
      if(r.hp <= 0) continue;
      // 20 hp, switch every 5
      const idx = clamp(4 - Math.ceil(r.hp/5), 0, 3);
      const img = IMG.rocks?.[idx];
      if(img) ctx.drawImage(img, r.x, r.y, r.w, r.h);
    }

 // bugs (glow while shooting)
for(const b of bugs){
  if(!b.alive) continue;

  if(b.glow > 0){
    drawGlow(
      b.x + b.w/2, b.y + b.h/2,
      b.w*0.55,
      (b.glow/0.18)*0.22,
      "rgba(120,255,200,0.55)"
    );
  }

  if(IMG.bug) ctx.drawImage(IMG.bug, b.x, b.y, b.w, b.h);

  // gold shield orb (filled, smaller, pulsing)
  if(b.shieldT > 0){
    const t = performance.now()/1000;
    const pulse = 0.5 + 0.5*Math.sin(t*6 + (b.bob||0));
    const cx = b.x + b.w/2;
    const cy = b.y + b.h/2;
    const r  = b.w * (0.42 + 0.03*pulse);

    ctx.save();
    ctx.globalCompositeOperation = "lighter";

    ctx.globalAlpha = 0.26 + 0.10*pulse;
    ctx.fillStyle = "rgba(255, 209, 102, 1)";
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.10 + 0.06*pulse;
    ctx.shadowBlur = 22 + 10*pulse;
    ctx.shadowColor = "rgba(255, 209, 102, 1)";
    ctx.fillStyle = "rgba(255, 209, 102, 1)";
    ctx.beginPath();
    ctx.arc(cx, cy, r*1.10, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }
} // <-- closes the bugs loop

    // bug shots (green glowing slime blobs)
    for(const bl of bugShots){
      if(bl.dead) continue;

      // outer soft glow
      drawGlow(
        bl.x,
        bl.y,
        bl.r * 2.8,
        0.18,
        "rgba(70,255,140,0.65)"
      );

      // inner glow (gives depth)
      drawGlow(
        bl.x,
        bl.y,
        bl.r * 1.6,
        0.22,
        "rgba(140,255,190,0.75)"
      );

      // solid slime core
      ctx.fillStyle = "rgba(90,255,150,0.95)";
      ctx.beginPath();
      ctx.arc(bl.x, bl.y, bl.r, 0, Math.PI*2);
      ctx.fill();
    }

    // boo shots (gold or pink)
    for(const s of booShots){
      if(s.dead) continue;

      if(s.isPink){
        drawGlow(s.x, s.y, 16, 0.22, "rgba(255,120,220,0.55)");
        ctx.fillStyle = "#ffd1ef";
        ctx.fillRect(s.x-2, s.y-10, 4, 14);
      } else {
        drawGlow(s.x, s.y, 16, 0.18, "rgba(255,214,102,0.55)");
        ctx.fillStyle = "#fff2c7";
        ctx.fillRect(s.x-2, s.y-10, 4, 14);
      }
    }

    // candy
    for(const c of candies){
      if(c.dead) continue;
      if(IMG.candy) ctx.drawImage(IMG.candy, c.x-18, c.y-18, 36, 36);
    }

    // sparkles
    if(sparkles.length){
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      for(const p of sparkles){
        const t = p.life / p.ttl;
        const a = 1 - t;
        ctx.globalAlpha = a;

        if(p.kind === "pink") ctx.fillStyle = "rgba(255,170,235,0.9)";
        else if(p.kind === "slime") ctx.fillStyle = "rgba(120,255,160,0.7)";
        else ctx.fillStyle = "rgba(255,230,140,0.85)";

        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
      ctx.globalAlpha = 1;
    }

    // player glow:
    // - subtle gold on normal shoot
    // - pink pulsate during sugar
    const px = player.x + player.w/2;
    const py = player.y + player.h/2;

    if(player.sugar > 0){
      // pink pulsate (subtle)
      const pulse = 0.5 + 0.5*Math.sin((performance.now()/1000)*6);
      drawGlow(px, py, player.w*0.50, 0.10 + pulse*0.08, "rgba(255,120,220,0.55)");
    } else if(player.glow > 0){
      drawGlow(px, py, player.w*0.45, 0.12, "rgba(255,214,102,0.55)");
    }

    
    // player sprite (shoot pose if a shot just fired recently)
    const isShootingPose = (booFireTimer > 0 && booFireTimer < 0.10);
    const pimg = isShootingPose ? IMG.booShoot : IMG.booIdle;

    // i-frame flicker (very subtle)
    if(player.hitIFrames > 0){
      ctx.globalAlpha = 0.78;
    }

    if(pimg) ctx.drawImage(pimg, player.x, player.y, player.w, player.h);
    else {
      ctx.fillStyle = "#ff7eb9";
      ctx.fillRect(player.x, player.y, player.w, player.h);
    }
    ctx.globalAlpha = 1;

    // HUD: energy meter + stage label
    const barX=16, barY=16, barW=150, barH=10;
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.fillRect(barX, barY, barW, barH);
    const fillW = barW * (player.energy/100);
    const color = (player.energy > 50) ? "rgba(255,214,102,0.95)"
                : (player.energy > 20) ? "rgba(255,180,120,0.95)"
                : "rgba(255,120,160,0.95)";
    ctx.fillStyle = color;
    ctx.fillRect(barX, barY, fillW, barH);

    ctx.font = "700 13px system-ui, -apple-system, sans-serif";
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.fillText("BOOHA INVADERS ‚Äî STAGE 1 DOTTY", 16, 44);

    // =========================
// QUIZ OVERLAY (Multiple Choice) ‚úÖ use the real overlay with red/green + JP message
// =========================
// =========================
// WAVE BANNER ‚úÖ Step 1
// =========================
drawWaveBanner();

// =========================
// QUIZ OVERLAY ...
// =========================
//drawQuizOverlay();



    // Game Over overlay
    if(player.energy <= 0){
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0,0,innerWidth,innerHeight);

      ctx.fillStyle = "rgba(255,255,255,0.94)";
      ctx.font = "900 38px system-ui, -apple-system, sans-serif";
      const msg = "GAME OVER";
      const mw = ctx.measureText(msg).width;
      ctx.fillText(msg, innerWidth/2 - mw/2, innerHeight/2 - 10);

      ctx.font = "700 16px system-ui, -apple-system, sans-serif";
      const msg2 = "Press R to Restart";
      const mw2 = ctx.measureText(msg2).width;
      ctx.fillText(msg2, innerWidth/2 - mw2/2, innerHeight/2 + 26);
      ctx.restore();
    }
  } // ‚úÖ end draw()

  // -----------------------
// Quiz helpers (Multiple Choice runtime) ‚úÖ feedback + retry + 1st-try reward
// -----------------------
let quizTried = [false,false,false,false];   // wrong attempts (red)
let quizSolved = false;                      // lock after correct
let quizFirstTry = true;                     // reward only if true
let quizMsg = "";                            // JP message

function quizHitTest(mx, my){
  const btnW = clamp(innerWidth*0.72, 260, 560);
  const btnH = 54;
  const gap = 14;
  const startY = innerHeight*0.42;
  const x = innerWidth/2 - btnW/2;

  for(let i=0;i<4;i++){
    const y = startY + i*(btnH+gap);
    if(mx >= x && mx <= x+btnW && my >= y && my <= y+btnH) return i;
  }
  return -1;
}

function restoreRocksAndEnergy(){
  // Energy restore
  player.energy = Math.min(100, player.energy + 25);

  // Rocks restore (bring back destroyed rocks + heal)
  for(const r of rocks){
    r.hp = Math.min(20, r.hp + 10);
  }
}

function closeQuiz(){
  // track quiz progress / difficulty
  quizCount++;

  // close quiz (this unfreezes the game loop)
  quizOpen = false;

  // reset quiz UI/state
  quizSolved = false;
  quizFirstTry = true;
  quizTried = [false,false,false,false];
  quizMsg = "";

  // prepare next question (but do NOT open it)
  nextQuiz();

  // --- START NEXT WAVE ---
  startWave(WaveState.wave + 1);
}


function answerQuiz(index){
  if(!quizOpen || !quizQ) return;

  // already solved: ignore extra taps
  if(quizSolved) return;

  // already tried wrong: ignore repeat taps on same wrong button
  if(quizTried[index]) return;

  const correct = (index === quizQ.correctIndex);

  if(!correct){
    // ‚ùå wrong: mark red, allow retry
    quizTried[index] = true;
    quizFirstTry = false;
    quizMsg = "„Å°„Åå„ÅÜÔºÅ„ÇÇ„ÅÜ„ÅÑ„Å°„Å©ÔºÅ";
    return;
  }

  // ‚úÖ correct: mark green, reward only if first try
  quizSolved = true;

  if(quizFirstTry){
    restoreRocksAndEnergy();
    quizMsg = "„Åô„Åî„ÅÑÔºÅ„Ç®„Éç„É´„ÇÆ„Éº„Å®„Éñ„É≠„ÉÉ„ÇØ„ÅåÂõûÂæ©„Åó„ÅüÔºÅ";
  } else {
    quizMsg = "Ê≠£Ëß£ÔºÅ";
  }

  // close after a short beat so they SEE green
  setTimeout(()=>{
    if(quizOpen) closeQuiz();
  }, 650);
}


  // -----------------------
  // Key handling (single, non-duplicated)
  // - R restarts on game over
  // - 1‚Äì4 answers during quiz
  // -----------------------
  addEventListener("keydown", (e)=>{
    // Restart (game over)
    if(player.energy <= 0){
      if(e.key === "r" || e.key === "R"){
        e.preventDefault();
        booFireTimer = 0;
        resetGame();
      }
      return;
    }

    // Quiz answers
    if(quizOpen){
      if(e.key === "1" || e.key === "2" || e.key === "3" || e.key === "4"){
        e.preventDefault();
        answerQuiz((e.key|0) - 1);
        return;
      }
      // optional: Escape closes quiz (counts as a completed question)
      if(e.key === "Escape"){
        e.preventDefault();
        closeQuiz();
        return;
      }
    }
  }, { passive:false });

// -----------------------
// Main loop
// -----------------------
function tick(ts){
  const t = ts / 1000;
  const dt = Math.min(0.033, (t - last) || 0);
  last = t;

  // ONLY run game logic when actually playing
  if(started && player.energy > 0 && !quizOpen){
    update(dt);
    updateFiring(dt);
    updateProjectiles(dt);
    updateCandy(dt);
    updateParticles(dt);

  

    // üîë wave system must be frozen with the game
    updateWaveSystem(dt);
  }

  draw();
  requestAnimationFrame(tick);
}



// -----------------------
// Reset Game (RESTORED ‚Äì required by boot())
// -----------------------
function resetGame(){
  resize();

  // player sizing
  player.w = clamp(innerWidth * 0.11, 68, 92);
  player.h = player.w;
  player.x = innerWidth/2 - player.w/2;
  player.y = innerHeight - player.h - 18;

  player.energy = 100;
  player.glow = 0;
  player.sugar = 0;
  player.hitIFrames = 0;

  // rocks
  rocks.length = 0;
  const count = 4;
  const rockW = clamp(innerWidth*0.18, 110, 160);
  const rockH = rockW * 0.72;
  const gap = (innerWidth - count*rockW) / (count+1);
  const ry = player.y - rockH - 55;

  for(let i=0;i<count;i++){
    rocks.push({
      x: gap + i*(rockW+gap),
      y: ry,
      w: rockW,
      h: rockH,
      hp: 20
    });
  }

  bugs.length = 0;
  booShots.length = 0;
  bugShots.length = 0;
  sparkles.length = 0;
  candies.length = 0;

  // quiz setup
  if(!quizDeck.length) buildQuizDeck();
  nextQuiz();

  stageTime = 0;
}

// -----------------------
// Boot
// -----------------------
(async function boot(){
  resize();

  try{
    const [bg, b1, b2, bug, candy, r1,r2,r3,r4] = await Promise.all([
      loadImg(ASSETS.bg),
      loadImg(ASSETS.booIdle),
      loadImg(ASSETS.booShoot),
      loadImg(ASSETS.bug),
      loadImg(ASSETS.candy),
      loadImg(ASSETS.rocks[0]),
      loadImg(ASSETS.rocks[1]),
      loadImg(ASSETS.rocks[2]),
      loadImg(ASSETS.rocks[3])
    ]);

    IMG.bg = bg;
    IMG.booIdle = b1;
    IMG.booShoot = b2;
    IMG.bug = bug;
    IMG.candy = candy;
    IMG.rocks = [r1,r2,r3,r4];
  } catch(err){
    console.warn(err);
  }

  // prepare clean state ONCE (do NOT start waves here)
  resetGame();

  // BGM (create once)
  let bgm = null;
  function startBGM(){
    if(bgm) return;
    bgm = new Audio("invaders-bgm.mp3");
    bgm.loop = true;
    bgm.volume = 0.6;
    bgm.play().catch(()=>{});
  }

  // START button (wire once)
startBtn.addEventListener("click", ()=>{
  started = true;
  quizOpen = false;

  // ‚úÖ reset shooting movement state
  lastPlayerX = player.x;
  playerMoving = false;
  shootResumeDelay = 0;

  document.getElementById("startOverlay").style.display = "none";

  startWave(1);
  startBGM();
});

   // start the game loop
  requestAnimationFrame(tick);
})();              // closes boot()


</script>
</body>
</html>

  
 
