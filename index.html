<!-- =========================
CHUNK 1 / 3
HEAD + STYLE
(doctype → </head>)
========================= -->

<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Booha Invaders — Stage 1 DOTTY</title>
<style>
  html,body{ margin:0; height:100%; background:#000; overflow:hidden; }
  canvas{ display:block; width:100vw; height:100vh; touch-action:none; }
</style>
</head>

</head>

<!-- =========================
END CHUNK 1 / 3
========================= -->

<!-- =========================
CHUNK 2 / 3
BODY + SCRIPT (PART 1)
(<body> → mid-script)
========================= -->

<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  // -----------------------
  // DPR / resize
  // -----------------------
  const DPR_CAP = 2;
  let DPR = 1;

  function resize(){
    DPR = Math.min(window.devicePixelRatio || 1, DPR_CAP);
    canvas.width  = Math.floor(innerWidth * DPR);
    canvas.height = Math.floor(innerHeight * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0); // draw in CSS px
  }
  addEventListener("resize", resize);

  // -----------------------
  // Assets (folders)
  // -----------------------
  const ASSETS = {
    bg:       "assets/background.png",
    booIdle:  "assets/booha-invad-1.png",
    booShoot: "assets/booha-invad-2.png",
    bug:      "assets/bug-1.png",
    candy:    "assets/candy.png",
    rocks: [
      "assets/rock1.png",
      "assets/rock2.png",
      "assets/rock3.png",
      "assets/rock4.png"
    ]
  };

  function loadImg(src){
    return new Promise((res, rej)=>{
      const img = new Image();
      img.onload = ()=>res(img);
      img.onerror = ()=>rej(new Error("Failed to load: " + src));
      img.src = src;
    });
  }

  const IMG = {};

  // -----------------------
  // Helpers
  // -----------------------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand  = (a,b)=>a + Math.random()*(b-a);

  function aabb(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  // cover background (no distortion)
  function drawCover(img){
    const W = innerWidth, H = innerHeight;
    const iw = img.width, ih = img.height;
    const s = Math.max(W/iw, H/ih);
    const dw = iw*s, dh = ih*s;
    const dx = (W - dw)/2;
    const dy = (H - dh)/2;
    ctx.drawImage(img, dx, dy, dw, dh);
  }

  // -----------------------
  // Question Popup (Multiple Choice 1–100)
  // ✅ SINGLE SOURCE OF TRUTH (declare ONCE here)
  // -----------------------
  let quizOpen  = false;
  let quizCount = 0;        // completed questions (Dotty scaling)
  let quizDeck  = [];
  let quizPos   = 0;
  let quizQ     = null;     // { n, choices:[...], correctIndex }

  // -----------------------
  // Quiz helpers (1–100 multiple choice)
  // -----------------------
  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j = (Math.random()*(i+1))|0;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  const ONES  = ["zero","one","two","three","four","five","six","seven","eight","nine"];
  const TEENS = ["ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen"];
  const TENS  = ["","","twenty","thirty","forty","fifty","sixty","seventy","eighty","ninety"];

  function numberToWords(n){
    if(n < 10) return ONES[n];
    if(n < 20) return TEENS[n-10];
    const t = (n/10)|0;
    const o = n % 10;
    if(o === 0) return TENS[t];
    return TENS[t] + "-" + ONES[o];
  }

  function splitDigitsWords(n){
    const t = (n/10)|0;
    const o = n % 10;
    return ONES[t] + " " + ONES[o]; // "two eight"
  }

  function twoEightyStyle(n){
    const t = (n/10)|0;
    return ONES[t] + "-" + TENS[t]; // "two-eighty"
  }

  function punChoice(n){
    const H = { one:"won", two:"too", four:"for", eight:"ate", zero:"oh" };
    if(n >= 10){
      const t = (n/10)|0;
      const o = n % 10;
      const a = H[ONES[t]] || ONES[t];
      const b = H[ONES[o]] || ONES[o];
      return a + "-" + b; // "too-ate"
    }
    const w = ONES[n];
    return (H[w] || ("the-" + w));
  }

  function makeQuestion(n){
    const correct = numberToWords(n);

    // 3 wrongs (intentionally a little silly)
    let wrong1, wrong2, wrong3;

    if(n >= 10){
      wrong1 = splitDigitsWords(n);
      wrong2 = twoEightyStyle(n);
      wrong3 = punChoice(n);
    } else {
      wrong1 = "the " + ONES[n];
      wrong2 = ONES[n] + "-" + ONES[n];
      wrong3 = punChoice(n);
    }

    // de-dupe + ensure not equal to correct
    const pool = [];
    for(const w of [wrong1, wrong2, wrong3]){
      if(!w) continue;
      if(w === correct) continue;
      if(pool.includes(w)) continue;
      pool.push(w);
    }
    while(pool.length < 3){
      const w = TENS[2 + ((Math.random()*8)|0)] + "-" + ONES[(Math.random()*10)|0];
      if(w !== correct && !pool.includes(w)) pool.push(w);
    }

    const choices = [correct, pool[0], pool[1], pool[2]];
    shuffle(choices);
    return { n, choices, correctIndex: choices.indexOf(correct) };
  }

  function buildQuizDeck(){
    quizDeck = [];
    for(let n=1;n<=100;n++) quizDeck.push(n);
    shuffle(quizDeck);
    quizPos = 0;
  }

  function nextQuiz(){
    if(!quizDeck.length) buildQuizDeck();
    if(quizPos >= quizDeck.length){
      shuffle(quizDeck);
      quizPos = 0;
    }
    const n = quizDeck[quizPos++];
    quizQ = makeQuestion(n);
  }

  // -----------------------
  // NOTE: Quiz overlay drawing DOES NOT belong in Chunk 2 update section.
  // Keeping your code (not deleting) but wrapping it so it doesn't run here.
  // Chunk 3 will call drawQuizOverlay() from inside draw().
  // -----------------------
  function drawQuizOverlay(){
// =========================
// QUIZ OVERLAY (Multiple Choice) ✅ shows red/green + message
// =========================
if(quizOpen && quizQ){
  ctx.save();

  // dim + vignette
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(0,0,innerWidth,innerHeight);

  const cx = innerWidth/2, cy = innerHeight/2;
  const r0 = Math.min(innerWidth, innerHeight) * 0.22;
  const r1 = Math.min(innerWidth, innerHeight) * 0.80;
  const vg = ctx.createRadialGradient(cx, cy, r0, cx, cy, r1);
  vg.addColorStop(0, "rgba(0,0,0,0)");
  vg.addColorStop(1, "rgba(0,0,0,0.65)");
  ctx.fillStyle = vg;
  ctx.fillRect(0,0,innerWidth,innerHeight);

  // Big number
  const q = String(quizQ.n);
  ctx.fillStyle = "rgba(255,255,255,0.96)";
  ctx.font = "900 72px system-ui, -apple-system, sans-serif";
  const qw = ctx.measureText(q).width;
  ctx.fillText(q, innerWidth/2 - qw/2, innerHeight*0.34);

  // Buttons layout (must match hit-test)
  const btnW = clamp(innerWidth*0.72, 260, 560);
  const btnH = 54;
  const gap = 14;
  const startY = innerHeight*0.42;
  const x = innerWidth/2 - btnW/2;

  ctx.font = "800 20px system-ui, -apple-system, sans-serif";

  for(let i=0;i<4;i++){
    const y = startY + i*(btnH+gap);

    // ✅ state colors
    const isCorrect = (quizSolved && i === quizQ.correctIndex);
    const isWrong   = (quizTried && quizTried[i]);

    let fill = "rgba(255,255,255,0.10)";
    let stroke = "rgba(255,255,255,0.22)";

    if(isWrong){
      fill = "rgba(255,60,90,0.22)";
      stroke = "rgba(255,60,90,0.55)";
    }
    if(isCorrect){
      fill = "rgba(60,255,140,0.22)";
      stroke = "rgba(60,255,140,0.65)";
    }

    ctx.fillStyle = fill;
    ctx.fillRect(x, y, btnW, btnH);

    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, btnW, btnH);

    const label = (i+1) + ")  " + quizQ.choices[i];
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.fillText(label, x + 16, y + 36);
  }

  // Hint
  ctx.font = "700 14px system-ui, -apple-system, sans-serif";
  ctx.fillStyle = "rgba(255,255,255,0.75)";
  const hint = "Tap an answer or press 1–4";
  const hw = ctx.measureText(hint).width;
  ctx.fillText(hint, innerWidth/2 - hw/2, startY + 4*(btnH+gap) + 12);

  // ✅ Message (JP)
  if(typeof quizMsg === "string" && quizMsg){
    ctx.font = "900 16px system-ui, -apple-system, sans-serif";
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    const mw = ctx.measureText(quizMsg).width;
    ctx.fillText(quizMsg, innerWidth/2 - mw/2, startY + 4*(btnH+gap) + 38);
  }

  ctx.restore();
} // ✅ closes: if(quizOpen && quizQ)

} // ✅ closes: function drawQuizOverlay()



  // -----------------------
  // Input (universal)
  // -----------------------
  let pointerDown = false;
  let pointerX = null;

  canvas.addEventListener("pointerdown", (e)=>{
    // ✅ QUIZ: tap an answer (do not start dragging)
    if(quizOpen){
      const idx = quizHitTest(e.clientX, e.clientY);
      if(idx >= 0) answerQuiz(idx);
      return;
    }

    e.preventDefault();
    pointerDown = true;
    pointerX = e.clientX;
    try { canvas.setPointerCapture(e.pointerId); } catch(_) {}
  }, { passive:false });

  canvas.addEventListener("pointermove", (e)=>{
    if(!pointerDown) return;
    e.preventDefault();
    pointerX = e.clientX;
  }, { passive:false });

  canvas.addEventListener("pointerup", (e)=>{
    pointerDown = false;
    pointerX = null;
    try { canvas.releasePointerCapture(e.pointerId); } catch(_) {}
  });

  canvas.addEventListener("pointercancel", (e)=>{
    pointerDown = false;
    pointerX = null;
    try { canvas.releasePointerCapture(e.pointerId); } catch(_) {}
  });

  addEventListener("mousemove", (e)=>{
    // Desktop: ignore mouse unless dragging
    if(!pointerDown) return;
    pointerX = e.clientX;
  });

  const keys = new Set();
  addEventListener("keydown", (e)=>{
    if(e.key === "ArrowLeft" || e.key === "ArrowRight"){
      e.preventDefault();
      pointerX = null; // ✅ keyboard takes control
    }
    keys.add(e.key);
  }, {passive:false});

  addEventListener("keyup", (e)=>keys.delete(e.key));

  // -----------------------
  // Entities
  // -----------------------
  const player = {
    x:0, y:0, w:80, h:80,
    energy: 100,
    glow: 0,          // small gold pulse when shooting
    sugar: 0,         // seconds remaining
    hitIFrames: 0     // invincibility window
  };

  const rocks = [];     // {x,y,w,h,hp}
  const bugs  = [];     // {x,y,w,h,alive, enterT, enterDur, tx,ty, bob, driftSpeed, fireCD, glow}
  const booShots = [];  // {x,y,vy,color,isPink,dead}
  const bugShots = [];  // {x,y,vx,vy,r,dead,t}
  const sparkles = [];  // {x,y,vx,vy,life,ttl,size,kind}
  const candies  = [];  // {x,y,vx,vy,spin,dead}

  // -----------------------
  // Question Popup (Multiple Choice 1–100)
  // (kept as-is from your file, but fixed to NOT redeclare)
  // -----------------------
  // let quizOpen = false;
  // let quizCount = 0;
  // let quizDeck = [];
  // let quizPos = 0;
  // let quizQ = null;

 // -----------------------
// Waves / pacing  ✅ NEW: mini-groups + quiz after 4th group
// -----------------------
const PATTERN_EARLY = [1, 2, 4, 8];
const PATTERN_LATE  = [8, 10, 12, 14]; // becomes spicy once x2 kicks in at 20 quizzes

let wave = 1;              // still used (for display / counting)
let stepInWave = 0;        // index into current pattern
let bugsThisStep = PATTERN_EARLY[0];
let spawnedThisStep = 0;
let killedThisStep = 0;
let spawnTimer = 0;

let candiesThisWave = 0;   // your candy cap per wave still works
let stageTime = 0;

// ✅ Spicy multiplier starts AFTER 20 quizzes
function dottyMultiplier(){
  if(quizCount < 20) return 1;                 // 0–19 quizzes: no multiplier
  return 1 + Math.floor(quizCount / 10);       // 20–29: 3x, 30–39: 4x, etc. (SPICY)
}

function currentPattern(){
  return (quizCount >= 20) ? PATTERN_LATE : PATTERN_EARLY;
}

function startWave(n){
  wave = n;
  stepInWave = 0;
  candiesThisWave = 0;
  startWaveStep();
}

function startWaveStep(){
  killedThisStep = 0;
  spawnedThisStep = 0;

  const pat = currentPattern();
  const baseCount = pat[stepInWave];
  bugsThisStep = baseCount * dottyMultiplier();

  spawnTimer = 0.6;
}

function advanceWaveStep(){
  stepInWave++;

  const pat = currentPattern();

  // ✅ After the 4th group: quiz
  if(stepInWave >= pat.length){
    nextQuiz();
    quizOpen = true;
    return;
  }

  startWaveStep();
}


  // -----------------------
  // Spawning DOTTY (20% larger)
  // -----------------------
  function spawnBug(){
    const bw = clamp(innerWidth * 0.078, 54, 78); // ~20% larger than earlier
    const bh = bw;

    const lanes = 6;
    const laneW = innerWidth / lanes;
    const lane = (Math.random()*lanes)|0;
    const tx = lane*laneW + laneW/2 - bw/2;
    const ty = clamp(innerHeight*0.18, 90, 150) + rand(0,40);

    const startX = tx + rand(-laneW*0.35, laneW*0.35);
    const startY = -bh - rand(30, 130);

    bugs.push({
      x: startX,
      y: startY,
      w: bw,
      h: bh,
      alive: true,

      // elegant entry
      enterT: 0,
      enterDur: rand(0.9, 1.3),
      sx: startX,
      sy: startY,
      tx, ty,

      bob: rand(0, 10),
      driftSpeed: 8,  // will ramp with stageTime
      fireCD: rand(2.6, 4.0), // calm at start
      glow: 0
    });
  }

  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
  function easeInOutSine(t){ return -(Math.cos(Math.PI * t) - 1) / 2; }

  // -----------------------
  // FX
  // -----------------------
  function addSpark(x,y, n=3, kind="gold"){
    for(let i=0;i<n;i++){
      sparkles.push({
        x, y,
        vx: rand(-120,120),
        vy: rand(-160,60),
        life: 0,
        ttl: rand(0.18, 0.34),
        size: rand(1.2, 2.6),
        kind
      });
    }
  }

  function dropCandy(){
    candies.push({
      x: rand(40, innerWidth-40),
      y: -30,
      vx: rand(-20, 20),
      vy: rand(70, 90),
      spin: rand(-2, 2),
      dead:false
    });
  }

  // -----------------------
  // Shooting rules
  // -----------------------
  // Normal: GOLD sparkly, one shot at a time (wait until clear)
  // Sugar:  PINK rapid shots + pink pulsate

  function canFireNormal(){
    // one-shot-at-a-time
    return booShots.length === 0;
  }

  function fireBooShot(isPink){
    booShots.push({
      x: player.x + player.w/2,
      y: player.y + 6,
      vy: isPink ? -1050 : -900,
      isPink,
      dead:false
    });

    // subtle glow when shooting (smaller)
    player.glow = isPink ? 0.10 : 0.12;
  }

  function fireBugShot(b){
    bugShots.push({
      x: b.x + b.w/2,
      y: b.y + b.h + 8,
      vx: rand(-55, 55),
      vy: rand(260, 340),
      r: rand(7, 10),
      t: 0,
      dead:false
    });
    b.glow = 0.18;
  }

 // -----------------------
// Update  ✅ candy interval + candy-powered shots after 10 quizzes
// -----------------------
let last = 0;

// Candy interval timer
let candyTimer = 10; // first drop happens ~10s in (tweak if you want)

function update(dt){
  if(player.energy <= 0) return;

  stageTime += dt;

  // drift ramps slowly (gentle -> faster)
  const driftBase = 10;
  const driftRamp = clamp((stageTime - 18) / 40, 0, 1);
  const driftNow  = driftBase + driftRamp * 28;

  // movement
  if(pointerX !== null){
    player.x = clamp(pointerX - player.w/2, 10, innerWidth - player.w - 10);
  } else {
    if(keys.has("ArrowLeft") || keys.has("a") || keys.has("A"))  player.x -= 420*dt;
    if(keys.has("ArrowRight") || keys.has("d") || keys.has("D")) player.x += 420*dt;
    player.x = clamp(player.x, 10, innerWidth - player.w - 10);
  }

  // timers
  player.glow = Math.max(0, player.glow - dt*2.2);
  player.sugar = Math.max(0, player.sugar - dt); // legacy (ok to leave)
  player.hitIFrames = Math.max(0, player.hitIFrames - dt);

  // spawn DOTTY for this step (SEQUENTIAL)
  spawnTimer -= dt;
  if(spawnedThisStep < bugsThisStep && spawnTimer <= 0){
    spawnBug();
    spawnedThisStep++;
    spawnTimer = 0.85;
  }

  // bugs update (enter + drift + shooting)
  for(const b of bugs){
    if(!b.alive) continue;

    b.glow = Math.max(0, b.glow - dt*2.0);
    b.bob += dt;

    // entry
    if(b.enterT < b.enterDur){
      b.enterT += dt;
      const t = clamp(b.enterT / b.enterDur, 0, 1);

      const curve = Math.sin(t*Math.PI) * (innerWidth*0.015) * (Math.random()<0.5?-1:1);
      b.x = b.sx + (b.tx - b.sx)*easeOutCubic(t) + curve*(1-t);
      b.y = b.sy + (b.ty - b.sy)*easeInOutSine(t);

    } else {

      // drift (gentle, then faster) + Boost 3 reaction
      let driftMult = 1;
      if(player.boost >= 3) driftMult = 1.6;

      b.driftSpeed = driftNow * driftMult;
      b.x = b.tx + Math.sin(b.bob*0.9) * b.driftSpeed;
      b.y = b.ty + Math.cos(b.bob*1.1) * (b.driftSpeed*0.32);

      // firing (starts calm, ramps with time) + Boost 3 reaction
      const fireRamp = clamp((stageTime - 12) / 40, 0, 1);
      let base = 3.4 - fireRamp*1.6;
      if(player.boost >= 3) base *= 0.6;

      b.fireCD -= dt;
      if(b.fireCD <= 0){
        fireBugShot(b);
        b.fireCD = rand(base, base + 1.0);
        b.fireCD = Math.max(0.6, b.fireCD);
      }
    }
  }
}

// We keep a dedicated shot timer to avoid weird cadence
let booFireTimer = 0;

function updateFiring(dt){
  booFireTimer -= dt;

  // ✅ Boost stacks (persistent until hit)
  // If you haven't added these yet, add to player object:
  // boost: 0
  const boost = player.boost || 0;   // 0..cap

  if(boost > 0){
    // Boosted shots (pink)
    // Stack 1 = stronger, Stack 2 = even more, Stack 3 = capped max
    const stack = clamp(boost, 1, 3);

    // fire rate gets a bit faster per stack (capped)
    const cooldown = Math.max(0.07, 0.12 - 0.015*(stack-1));

    // max simultaneous shots increases with stacks (capped)
    const maxPinkShots = [0, 3, 6, 9][stack];

    if(booFireTimer <= 0 && booShots.length < maxPinkShots){
      fireBooShot(true);
      booFireTimer = cooldown;
    }

  } else {
    // Normal (gold), one-at-a-time
    const cooldown = 0.12;
    if(booFireTimer <= 0 && canFireNormal()){
      fireBooShot(false);
      booFireTimer = cooldown;
    }
  }
}


  function updateProjectiles(dt){
    // boo shots
    for(const s of booShots){
      if(s.dead) continue;
      s.y += s.vy * dt;

      // sparkly trail
      if(s.isPink){
        addSpark(s.x + rand(-2,2), s.y + 10 + rand(-2,2), 2, "pink");
      } else {
        addSpark(s.x + rand(-2,2), s.y + 10 + rand(-2,2), 2, "gold");
      }

      // hit bugs
      for(const b of bugs){
        if(!b.alive) continue;
        if(aabb(s.x-5, s.y-10, 10, 18, b.x, b.y, b.w, b.h)){
          b.alive = false;
          s.dead = true;
          killedThisStep++;

          addSpark(b.x+b.w/2, b.y+b.h/2, 14, s.isPink ? "pink":"gold");
          break;
        }
      }

      // offscreen
      if(s.y < -40) s.dead = true;
    }

    // bug shots (green blobs)
    for(const bl of bugShots){
      if(bl.dead) continue;
      bl.t += dt;
      const wob = Math.sin(bl.t*6) * 0.8;

      bl.x += (bl.vx * (1+wob)) * dt;
      bl.y += bl.vy * dt;

      // hit rocks
      for(const r of rocks){
        if(r.hp <= 0) continue;
        if(aabb(bl.x-bl.r, bl.y-bl.r, bl.r*2, bl.r*2, r.x, r.y, r.w, r.h)){
          r.hp = Math.max(0, r.hp - 1);
          bl.dead = true;
          // a little slime puff via sparkles in green
          addSpark(bl.x, bl.y, 8, "slime");
          break;
        }
      }

      // hit player (with i-frames)
// hit player (with i-frames)
if(!bl.dead && player.hitIFrames <= 0){
  if(aabb(bl.x-bl.r, bl.y-bl.r, bl.r*2, bl.r*2, player.x, player.y, player.w, player.h)){
    bl.dead = true;

    // damage
    player.energy = Math.max(0, player.energy - 10);
    player.hitIFrames = 0.55;

    // ✅ RESET BOOST STACKS ON HIT
    player.boost = 0;

    // visual feedback
    addSpark(player.x+player.w/2, player.y+player.h/2, 12, "slime");
  }
}

      if(bl.y > innerHeight + 80) bl.dead = true;
    }

    // cleanup arrays (real cleanup, not a no-op)
    for(let i=booShots.length-1;i>=0;i--){
      if(booShots[i].dead) booShots.splice(i,1);
    }
    for(let i=bugShots.length-1;i>=0;i--){
      if(bugShots[i].dead) bugShots.splice(i,1);
    }
    for(let i=bugs.length-1;i>=0;i--){
      if(!bugs[i].alive) bugs.splice(i,1);
    }
  }

 function updateCandy(dt){
  for(const c of candies){
    if(c.dead) continue;
    c.x += c.vx * dt;
    c.y += c.vy * dt;

    // sparkle as it falls
    addSpark(c.x + rand(-6,6), c.y + rand(-6,6), 1, "pink");

    // catch
    if(aabb(c.x-18, c.y-18, 36, 36, player.x, player.y, player.w, player.h)){
      c.dead = true;

      // ✅ BOOST STACKS (persist until hit)
      // 1 candy = +1 stack, 2 candies = +2 stacks, capped at 3
      player.boost = clamp((player.boost || 0) + 1, 0, 3);

      // small restore (keep this)
      player.energy = Math.min(100, player.energy + 30);

      // turn off old timer-based sugar (so boost is the only system)
      player.sugar = 0;

      // little pulse
      player.glow = 0.12;
    }

    if(c.y > innerHeight + 60) c.dead = true;
  }

  for(let i=candies.length-1;i>=0;i--){
    if(candies[i].dead) candies.splice(i,1);
  }
}


  function updateParticles(dt){
    for(const p of sparkles){
      p.life += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 280 * dt;
    }
    for(let i=sparkles.length-1;i>=0;i--){
      if(sparkles[i].life >= sparkles[i].ttl) sparkles.splice(i,1);
    }
  }

  function maybeAdvanceRound(){
    // Only advance when:
    // 1) we’ve killed the target for this step AND
    // 2) there are no living DOTTY left on screen
    if(killedThisStep >= bugsThisStep){
      const anyAlive = bugs.some(b => b.alive);
      if(!anyAlive){
        advanceWaveStep();
      }
    }
  }

  /* =========================
  END CHUNK 2 / 3
  (stop here – logic & updates above)
  ========================= */


/* =========================
CHUNK 3 / 3
SCRIPT (PART 2) + END
(Draw → </html>)
========================= */

  // -----------------------
  // Draw
  // -----------------------

  function drawGlow(x,y,r,alpha,color){
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function draw(){
    // background
    if(IMG.bg) drawCover(IMG.bg);
    else {
      ctx.fillStyle = "#050014";
      ctx.fillRect(0,0,innerWidth,innerHeight);
    }

    // rocks
    for(const r of rocks){
      if(r.hp <= 0) continue;
      // 20 hp, switch every 5
      const idx = clamp(4 - Math.ceil(r.hp/5), 0, 3);
      const img = IMG.rocks?.[idx];
      if(img) ctx.drawImage(img, r.x, r.y, r.w, r.h);
    }

    // bugs (glow while shooting)
    for(const b of bugs){
      if(!b.alive) continue;

      if(b.glow > 0){
        drawGlow(
          b.x + b.w/2, b.y + b.h/2,
          b.w*0.55,
          (b.glow/0.18)*0.22,
          "rgba(120,255,200,0.55)"
        );
      }
      if(IMG.bug) ctx.drawImage(IMG.bug, b.x, b.y, b.w, b.h);
    }

    // bug shots (green glowing slime blobs)
    for(const bl of bugShots){
      if(bl.dead) continue;

      // outer soft glow
      drawGlow(
        bl.x,
        bl.y,
        bl.r * 2.8,
        0.18,
        "rgba(70,255,140,0.65)"
      );

      // inner glow (gives depth)
      drawGlow(
        bl.x,
        bl.y,
        bl.r * 1.6,
        0.22,
        "rgba(140,255,190,0.75)"
      );

      // solid slime core
      ctx.fillStyle = "rgba(90,255,150,0.95)";
      ctx.beginPath();
      ctx.arc(bl.x, bl.y, bl.r, 0, Math.PI*2);
      ctx.fill();
    }

    // boo shots (gold or pink)
    for(const s of booShots){
      if(s.dead) continue;

      if(s.isPink){
        drawGlow(s.x, s.y, 16, 0.22, "rgba(255,120,220,0.55)");
        ctx.fillStyle = "#ffd1ef";
        ctx.fillRect(s.x-2, s.y-10, 4, 14);
      } else {
        drawGlow(s.x, s.y, 16, 0.18, "rgba(255,214,102,0.55)");
        ctx.fillStyle = "#fff2c7";
        ctx.fillRect(s.x-2, s.y-10, 4, 14);
      }
    }

    // candy
    for(const c of candies){
      if(c.dead) continue;
      if(IMG.candy) ctx.drawImage(IMG.candy, c.x-18, c.y-18, 36, 36);
    }

    // sparkles
    if(sparkles.length){
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      for(const p of sparkles){
        const t = p.life / p.ttl;
        const a = 1 - t;
        ctx.globalAlpha = a;

        if(p.kind === "pink") ctx.fillStyle = "rgba(255,170,235,0.9)";
        else if(p.kind === "slime") ctx.fillStyle = "rgba(120,255,160,0.7)";
        else ctx.fillStyle = "rgba(255,230,140,0.85)";

        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
      ctx.globalAlpha = 1;
    }

    // player glow:
    // - subtle gold on normal shoot
    // - pink pulsate during sugar
    const px = player.x + player.w/2;
    const py = player.y + player.h/2;

    if(player.sugar > 0){
      // pink pulsate (subtle)
      const pulse = 0.5 + 0.5*Math.sin((performance.now()/1000)*6);
      drawGlow(px, py, player.w*0.50, 0.10 + pulse*0.08, "rgba(255,120,220,0.55)");
    } else if(player.glow > 0){
      drawGlow(px, py, player.w*0.45, 0.12, "rgba(255,214,102,0.55)");
    }

    // player sprite (shoot pose if a shot just fired recently)
    const isShootingPose = (booFireTimer > 0 && booFireTimer < 0.10);
    const pimg = isShootingPose ? IMG.booShoot : IMG.booIdle;

    // i-frame flicker (very subtle)
    if(player.hitIFrames > 0){
      ctx.globalAlpha = 0.78;
    }

    if(pimg) ctx.drawImage(pimg, player.x, player.y, player.w, player.h);
    else {
      ctx.fillStyle = "#ff7eb9";
      ctx.fillRect(player.x, player.y, player.w, player.h);
    }
    ctx.globalAlpha = 1;

    // HUD: energy meter + stage label
    const barX=16, barY=16, barW=150, barH=10;
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.fillRect(barX, barY, barW, barH);
    const fillW = barW * (player.energy/100);
    const color = (player.energy > 50) ? "rgba(255,214,102,0.95)"
                : (player.energy > 20) ? "rgba(255,180,120,0.95)"
                : "rgba(255,120,160,0.95)";
    ctx.fillStyle = color;
    ctx.fillRect(barX, barY, fillW, barH);

    ctx.font = "700 13px system-ui, -apple-system, sans-serif";
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.fillText("BOOHA INVADERS — STAGE 1 DOTTY", 16, 44);

    // =========================
    // QUIZ OVERLAY (Multiple Choice)
    // =========================
    if(quizOpen && quizQ){
      ctx.save();

      // dim + vignette
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0,0,innerWidth,innerHeight);

      const cx = innerWidth/2, cy = innerHeight/2;
      const r0 = Math.min(innerWidth, innerHeight) * 0.22;
      const r1 = Math.min(innerWidth, innerHeight) * 0.80;
      const vg = ctx.createRadialGradient(cx, cy, r0, cx, cy, r1);
      vg.addColorStop(0, "rgba(0,0,0,0)");
      vg.addColorStop(1, "rgba(0,0,0,0.65)");
      ctx.fillStyle = vg;
      ctx.fillRect(0,0,innerWidth,innerHeight);

      // Big number
      const q = String(quizQ.n);
      ctx.fillStyle = "rgba(255,255,255,0.96)";
      ctx.font = "900 72px system-ui, -apple-system, sans-serif";
      const qw = ctx.measureText(q).width;
      ctx.fillText(q, innerWidth/2 - qw/2, innerHeight*0.34);

      // Buttons layout (must match hit-test)
      const btnW = clamp(innerWidth*0.72, 260, 560);
      const btnH = 54;
      const gap = 14;
      const startY = innerHeight*0.42;
      const x = innerWidth/2 - btnW/2;

      ctx.font = "800 20px system-ui, -apple-system, sans-serif";

      for(let i=0;i<4;i++){
        const y = startY + i*(btnH+gap);

        ctx.fillStyle = "rgba(255,255,255,0.10)";
        ctx.fillRect(x, y, btnW, btnH);

        ctx.strokeStyle = "rgba(255,255,255,0.22)";
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, btnW, btnH);

        const label = (i+1) + ")  " + quizQ.choices[i];
        ctx.fillStyle = "rgba(255,255,255,0.92)";
        ctx.fillText(label, x + 16, y + 36);
      }

      ctx.font = "700 14px system-ui, -apple-system, sans-serif";
      ctx.fillStyle = "rgba(255,255,255,0.75)";
      const hint = "Tap an answer or press 1–4";
      const hw = ctx.measureText(hint).width;
      ctx.fillText(hint, innerWidth/2 - hw/2, startY + 4*(btnH+gap) + 12);

      ctx.restore();
    }

    // Game Over overlay
    if(player.energy <= 0){
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0,0,innerWidth,innerHeight);

      ctx.fillStyle = "rgba(255,255,255,0.94)";
      ctx.font = "900 38px system-ui, -apple-system, sans-serif";
      const msg = "GAME OVER";
      const mw = ctx.measureText(msg).width;
      ctx.fillText(msg, innerWidth/2 - mw/2, innerHeight/2 - 10);

      ctx.font = "700 16px system-ui, -apple-system, sans-serif";
      const msg2 = "Press R to Restart";
      const mw2 = ctx.measureText(msg2).width;
      ctx.fillText(msg2, innerWidth/2 - mw2/2, innerHeight/2 + 26);
      ctx.restore();
    }
  } // ✅ end draw()

  // -----------------------
// Quiz helpers (Multiple Choice runtime) ✅ feedback + retry + 1st-try reward
// -----------------------
let quizTried = [false,false,false,false];   // wrong attempts (red)
let quizSolved = false;                      // lock after correct
let quizFirstTry = true;                     // reward only if true
let quizMsg = "";                            // JP message

function quizHitTest(mx, my){
  const btnW = clamp(innerWidth*0.72, 260, 560);
  const btnH = 54;
  const gap = 14;
  const startY = innerHeight*0.42;
  const x = innerWidth/2 - btnW/2;

  for(let i=0;i<4;i++){
    const y = startY + i*(btnH+gap);
    if(mx >= x && mx <= x+btnW && my >= y && my <= y+btnH) return i;
  }
  return -1;
}

function restoreRocksAndEnergy(){
  // Energy restore
  player.energy = Math.min(100, player.energy + 25);

  // Rocks restore (bring back destroyed rocks + heal)
  for(const r of rocks){
    r.hp = Math.min(20, r.hp + 10);
  }
}

function closeQuiz(){
  quizCount++;           // ✅ drives difficulty
  quizOpen = false;

  // reset quiz state for next time
  quizSolved = false;
  quizFirstTry = true;
  quizTried = [false,false,false,false];
  quizMsg = "";

  // get next question ready (but do NOT open it)
  nextQuiz();

  // ✅ IMPORTANT: reset pacing so we don't instantly reopen the quiz
  wave++;
  stepInWave = 0;
  candiesThisWave = 0;

  killedThisStep = 0;
  spawnedThisStep = 0;
  spawnTimer = 0.6;

  startWaveStep();
}


function answerQuiz(index){
  if(!quizOpen || !quizQ) return;

  // already solved: ignore extra taps
  if(quizSolved) return;

  // already tried wrong: ignore repeat taps on same wrong button
  if(quizTried[index]) return;

  const correct = (index === quizQ.correctIndex);

  if(!correct){
    // ❌ wrong: mark red, allow retry
    quizTried[index] = true;
    quizFirstTry = false;
    quizMsg = "ちがう！もういちど！";
    return;
  }

  // ✅ correct: mark green, reward only if first try
  quizSolved = true;

  if(quizFirstTry){
    restoreRocksAndEnergy();
    quizMsg = "すごい！エネルギーとブロックが回復した！";
  } else {
    quizMsg = "正解！";
  }

  // close after a short beat so they SEE green
  setTimeout(()=>{
    if(quizOpen) closeQuiz();
  }, 650);
}


  // -----------------------
  // Key handling (single, non-duplicated)
  // - R restarts on game over
  // - 1–4 answers during quiz
  // -----------------------
  addEventListener("keydown", (e)=>{
    // Restart (game over)
    if(player.energy <= 0){
      if(e.key === "r" || e.key === "R"){
        e.preventDefault();
        booFireTimer = 0;
        resetGame();
      }
      return;
    }

    // Quiz answers
    if(quizOpen){
      if(e.key === "1" || e.key === "2" || e.key === "3" || e.key === "4"){
        e.preventDefault();
        answerQuiz((e.key|0) - 1);
        return;
      }
      // optional: Escape closes quiz (counts as a completed question)
      if(e.key === "Escape"){
        e.preventDefault();
        closeQuiz();
        return;
      }
    }
  }, { passive:false });

  // -----------------------
  // Main loop
  // -----------------------
  function tick(ts){
    const t = ts/1000;
    const dt = Math.min(0.033, (t - last) || 0);
    last = t;

    if(player.energy > 0 && !quizOpen){
      update(dt);
      updateFiring(dt);
      updateProjectiles(dt);
      updateCandy(dt);
      updateParticles(dt);
      maybeAdvanceRound();
    }

    draw();
    requestAnimationFrame(tick);
  }


// -----------------------
// Reset Game (RESTORED – required by boot())
// -----------------------
function resetGame(){
  resize();

  // player sizing
  player.w = clamp(innerWidth * 0.11, 68, 92);
  player.h = player.w;
  player.x = innerWidth/2 - player.w/2;
  player.y = innerHeight - player.h - 18;

  player.energy = 100;
  player.glow = 0;
  player.sugar = 0;
  player.hitIFrames = 0;

  // rocks
  rocks.length = 0;
  const count = 4;
  const rockW = clamp(innerWidth*0.18, 110, 160);
  const rockH = rockW * 0.72;
  const gap = (innerWidth - count*rockW) / (count+1);
  const ry = player.y - rockH - 55;

  for(let i=0;i<count;i++){
    rocks.push({
      x: gap + i*(rockW+gap),
      y: ry,
      w: rockW,
      h: rockH,
      hp: 20
    });
  }

  bugs.length = 0;
  booShots.length = 0;
  bugShots.length = 0;
  sparkles.length = 0;
  candies.length = 0;

  // quiz setup
  if(!quizDeck.length) buildQuizDeck();
  nextQuiz();

  stageTime = 0;
  startWave(1);
}


  
  // -----------------------
  // Boot
  // -----------------------
  (async function boot(){
    resize();

    try{
      const [
        bg, b1, b2, bug, candy,
        r1,r2,r3,r4
      ] = await Promise.all([
        loadImg(ASSETS.bg),
        loadImg(ASSETS.booIdle),
        loadImg(ASSETS.booShoot),
        loadImg(ASSETS.bug),
        loadImg(ASSETS.candy),
        loadImg(ASSETS.rocks[0]),
        loadImg(ASSETS.rocks[1]),
        loadImg(ASSETS.rocks[2]),
        loadImg(ASSETS.rocks[3])
      ]);

      IMG.bg = bg;
      IMG.booIdle = b1;
      IMG.booShoot = b2;
      IMG.bug = bug;
      IMG.candy = candy;
      IMG.rocks = [r1,r2,r3,r4];
    } catch(err){
      console.warn(err);
    }

    resetGame();
    requestAnimationFrame(tick);
  })();

})();
</script>
</body>
</html>

